{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction to UPSET","text":""},{"location":"index.html#scope-of-this-document","title":"Scope of this Document","text":"<p>This document is intended to provide an overview of the UPSET tool usage and flow, detailing some of the tool's technical features and capabilities. It is not intended to be a comprehensive guide to the tool, but rather a starting point for users who are new to the tool and want to understand its basic functionality.</p>"},{"location":"index.html#what-is-upset","title":"What is UPSET?","text":"<p>UPSET is a Single Event Transient (SET) Analysis tool, supporting both SET Generation and Propagation for whole circuits, based on Static Timing Analysis (STA). STA emulates signal propagation, from all timing path start points, through combinational logic to circuit endpoints, by propagating both rise/fall delays and slews and supports both the standard NLDM (Non-Linear Delay Model), as well as the more advanced CCS (Composite Current Source) timing model. By utilising CASlab's STA engine for SET generation and propagation, UPSET is able to model transient faults, originated by particle strikes, (i) with acceptable loss of accuracy over SPICE, and (ii) using Static analysis over simulation, resulting in many orders of magnitude of speedup.</p>"},{"location":"appendix.html","title":"Appendices","text":""},{"location":"appendix.html#appendix-a-eco-set-analysis","title":"Appendix A: ECO SET Analysis","text":"<p>Beyond the SET Analysis Flow presented in page UPSET SET Analysis Flow the user can perform ECO SET Analysis, by generating and propagation custom SET pulses.</p>"},{"location":"appendix.html#a1-eco-set-generation","title":"A.1 ECO SET Generation","text":"<p>A custom SET glitch can be generated by providing the <code>drivergatepin</code> (where the strike happened), and <code>endpoint</code> (where the measurements are taken) and the DEXP current source parameters (<code>tdelay</code>, <code>tau1</code>, <code>tau2</code>, <code>q</code>), using the TCL command:</p> <p><pre><code>%&gt; generate_SET_glitch -scenario &lt;drivergatepin&gt; &lt;endpoint&gt; &lt;tdelay&gt; &lt;tau1&gt; &lt;tau2&gt; &lt;q&gt; -corner &lt;corner_index&gt;\n</code></pre> , where the argument <code>-scenario</code> specifies the scenario characteristics and the argument <code>-corner</code> specifies the library corner to be used for the SET glitch generation.</p>"},{"location":"appendix.html#a2-eco-set-propagation","title":"A.2 ECO SET Propagation","text":"<p>Propagating a custom SET pulse from a specified input gatepin to the forward logic cone can be done using the TCL command:</p> <pre><code>%&gt; propagate_SET_glitch -gatepin &lt;receivergatepinname&gt; -rise {risearrival_1 riseslew_1 ... risearrival_N riseslew_N} -fall {fallarrival_1 fallslew_1 ... fallarrival_N fallslew_N} ?-corner &lt;corner_index&gt;?\n</code></pre> <p>, where the argument <code>-gatepin</code> specifies the name of the input gatepin from where the SET propagation starts and the arguments <code>-rise</code> and <code>-fall</code> specify the lists of rise/fall arrival times and slews which specify the SET pulse to be propagated.</p>"},{"location":"appendix.html#appendix-b-custom-simulation","title":"Appendix B: Custom Simulation","text":""},{"location":"appendix.html#b1-simulation","title":"B.1 Simulation","text":"<p>To simulate a pulse for a given net, a supply is needed, which can be either a voltage or current source. The supply can be either described using a transient specification. Currently, the supported transient specifications are Piece-Wise Linear (PWL), and Double Exponential (DEXP). Also, arguments for the aforementioned Transient specifications are needed. Also, the given name for the supply, either starting with \"V\" or \"I\", specified the type of the supply (like SPICE voltage sources start with \"V\", whereas current sources start with \"I\").</p> <p>Creating a net supply can be done using the following TCL command:</p> <pre><code>%&gt; set_net_supply &lt;supplyname&gt; &lt;drivergatepin&gt; &lt;groundname&gt; &lt;transientspec&gt; {&lt;transientspec args&gt;}\n</code></pre> <p>, where the argument <code>{&lt;transientspec args&gt;}</code> is used to specify the arguments for the transient specification of the supply. A PWL supply is specified by using a list of time and voltage sets, whereas a DEXP supply is specified using a list of the Double Exponential Current Source model arguments (tdelay, tau1, tau2, q).</p> <p>Example</p> <p>PWL list example: <code>{1n 0 1.5n 0 2n 0.7 2.5n 0.7 3n 0}</code></p> <p>DEXP list example: <code>{0.5n 47p 647p 282f}</code></p> <p>Running a custom SPICE simulation in a specified net, with the beforehand specified supply can be done using the TCL command:</p> <pre><code>%&gt; simulate_net &lt;driver_gatepin&gt;\n</code></pre> <p>UPSET simulation is performed using a predefined time step and total duration. These parameters can be specified using the TCL command:</p> <pre><code>%&gt; set_spice_simulation_parameters -timestep &lt;timestepvalue&gt; -totalduration &lt;totaldurationvalue&gt;\n</code></pre>"},{"location":"appendix.html#b2-node-measurements","title":"B.2 Node Measurements","text":"<p>To measure the voltage and/or the current of the generated SET glitch to a specified node, SPICE probes are used, which store the SPICE simulation data. Voltage probes are specified at a single node with reference to GND, while current probes are specified at net supplies. After the simulation, the data are stored in the probes and they can be plotted to see the current or voltage waveform.</p> <p>Creating a SPICE probe can be done using the TCL command:</p> <pre><code>%&gt; create_net_spice_probe &lt;drivergatepin&gt; (-node &lt;spefnodename&gt; | -vsource &lt;voltagesourcename&gt; | -all) ?-longest | -shortest?\n</code></pre> <p>and it can be plotted using the TCL command:</p> <pre><code>%&gt; plot_spice_probe {probelist}\n</code></pre> <p>The list of the defined SPICE probes can be reported using the TCL command:</p> <pre><code>%&gt; list_spice_probes\n</code></pre>"},{"location":"commands_reference.html","title":"Commands Reference Manual","text":""},{"location":"commands_reference.html#load_lef","title":"load_lef","text":"<p>Import LEF library files. Technology LEF, i.e. the LEF containing the routing layer info, must be the first in the line.</p> <p>Syntax:</p> <pre><code>%&gt; load_lef {&lt;filenames&gt;}\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;filenames&gt;</code> is the list of the LEF files to be loaded</li> </ul>"},{"location":"commands_reference.html#load_lib","title":"load_lib","text":"<p>Import LIB library files. Each LIB file is read as a corner. Error reporting is enabled using the <code>-errors</code> flag.</p> <p>Syntax:</p> <pre><code>%&gt; load_lib {&lt;filenames&gt;} ?-errors?\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;filenames&gt;</code> is the list of the LIB files to be loaded</li> <li><code>-errors</code> is an optional flag that enables error reporting</li> </ul>"},{"location":"commands_reference.html#load_verilog","title":"load_verilog","text":"<p>Import design. Supported format is gate-level Verilog netlist.</p> <p>Syntax:</p> <pre><code>%&gt; load_verilog {&lt;filenames&gt;}\n</code></pre>"},{"location":"commands_reference.html#load_spef","title":"load_spef","text":"<p>Import design parasitics. Supported format is SPEF. Different parasitics may be used for worst case and best case analysis Arguments <code>-longest</code> and <code>-shortest</code> are used to associate parasitics with analysis type. Error report is enabled using the <code>-errors</code> flag.</p> <p>Syntax:</p> <pre><code>%&gt; load_spef (-longest | -shortest) ?-errors? {filenames}\n</code></pre> <p>Arguments:</p> <ul> <li><code>-longest</code>is for the worst case analysis</li> <li><code>-shortest</code> is for the best case analysis</li> <li><code>-errors</code> is an optional flag that enables error reporting</li> </ul>"},{"location":"commands_reference.html#readload_saif","title":"read/load_saif","text":"<p>Import SAIF file. A SAIF file is used to annotate the circuit of each gatepin switching activity and logic state duration during simulation.</p> <p>Syntax:</p> <pre><code>%&gt; read_saif &lt;saif_file_&gt;\n# or alternatively\n%&gt; load_saif &lt;saif_file_&gt;\n</code></pre>"},{"location":"commands_reference.html#list_saif_info","title":"list_saif_info","text":"<p>List all SAIF information stored in memory.</p> <p>Syntax:</p> <pre><code>%&gt; list_saif_info\n</code></pre>"},{"location":"commands_reference.html#set_timing_model","title":"set_timing_model","text":"<p>Define the timing model used in the current session.</p> <p>Syntax:</p> <pre><code>%&gt; set_timing_model &lt;nldm | ccs&gt;\n</code></pre>"},{"location":"commands_reference.html#set_timing_rc_mode","title":"set_timing_RC_mode","text":"<p>Define the interconnect timing model used in the current session.</p> <p>Syntax:</p> <pre><code>%&gt; set_timing_RC_mode &lt;lumpedRC | pimodelRC | detailedRC&gt;\n</code></pre>"},{"location":"commands_reference.html#set_set_analysis_mode","title":"set_SET_analysis_mode","text":"<p>Set the SET analysis mode. Two modes are available, Vector-based and Probabilistic. Each mode is described at Section SET Propagation STA-modes. The default analysis mode is Vector-based.</p> <p>Syntax:</p> <pre><code>%&gt; set_SET_analysis_mode &lt;0: Vector-based | 1: Probabilistic&gt;\n</code></pre> <p>Example</p> <pre><code>%&gt; set_SET_analysis_mode 0\n</code></pre>"},{"location":"commands_reference.html#create_clock","title":"create_clock","text":"<p>Create a clock in the current design and define its waveform. The <code>-waveform</code> argument is optional and can be used to create a pulse whose edges are explicitly defined with the given timestamps.</p> <p>Syntax:</p> <pre><code>%&gt; create_clock &lt;source_gatepin&gt; -period &lt;period_value&gt; ?-name &lt;clock_name&gt;? ?-waveform {edge_list}?\n</code></pre> <p>Arguments:</p> <ul> <li><code>-period</code> is the period of the clock</li> <li><code>-name</code> is the name of the clock</li> <li><code>-waveform</code> is the waveform rise and fall edge pairs</li> </ul> <p>Example</p> <pre><code>%&gt; create_clock clk -name clk -period 10 -waveform {0 8}\n</code></pre>"},{"location":"commands_reference.html#set_input_delay","title":"set_input_delay","text":"<p>Set delay from environment launching elements to design Top-Level inputs and constrain them. Specified delay may be used for worst case or best case analysis. Also, specified delay direction can be either rise or fall. Input delay must be specified with reference to a clock. Argument <code>-clock</code> is used to specify the reference clock.</p> <p>Syntax:</p> <pre><code>%&gt; set_input_delay &lt;delay_value&gt; ?-clock &lt;clock_name&gt;? ?-rise|-fall? ?-max|-min? ?-add_delay? {port_pin_list}\n</code></pre> <p>Arguments:</p> <ul> <li><code>-clock</code> is the name of the reference clock</li> <li><code>-rise</code> is for rise delay specification</li> <li><code>-fall</code> is for fall delay specification</li> <li><code>-max</code> is for worst case analysis</li> <li><code>-min</code> is for best case analysis</li> <li><code>-add_delay</code> is used to add the specified delay to the already stored delay</li> </ul>"},{"location":"commands_reference.html#set_output_delay","title":"set_output_delay","text":"<p>Set delay from design Top-Level outputs to environment capturing elements and constrain them. The specified delay must be used either for worst-case or best-case analysis. Also, the specified delay direction can be either rise or fall. Output delay must be specified with reference to a capturing clock. Argument <code>-clock</code> is used to specify the reference clock.</p> <p>Syntax:</p> <pre><code>%&gt; set_output_delay &lt;delay_value&gt; ?-clock &lt;clock_name&gt;? ?-rise|-fall? ?-max|-min? ?-add_delay? {port_pin_list}\n</code></pre> <p>Arguments:</p> <ul> <li><code>-clock</code> is the name of the reference clock</li> <li><code>-rise</code> is for rise delay specification</li> <li><code>-fall</code> is for fall delay specification</li> <li><code>-max</code> is for worst case analysis</li> <li><code>-min</code> is for best case analysis</li> <li><code>-add_delay</code> is used to add the specified delay to the already stored delay</li> </ul>"},{"location":"commands_reference.html#report_timing","title":"report_timing","text":"<p>Perform STA using the specified library corner. Both worst case and best case analysis are supported. Also, for performance reasons, slack is calculated by default only on timing path endpoints. Argument <code>-backannotate</code> is used to calculate global slack.</p> <p>Syntax:</p> <pre><code>%&gt; report_timing ?-longest|-shortest -corner &lt;corner_index&gt;? ?-backannotate?\n</code></pre> <p>Arguments:</p> <ul> <li><code>-longest</code> is for the worst case analysis</li> <li><code>-shortest</code> is for the best case analysis</li> <li><code>-corner</code> is used to select the library corner to be used for the STA timing analysis</li> <li><code>-backannotate</code> is used to calculate global slack</li> </ul>"},{"location":"commands_reference.html#create_particle_profile","title":"create_particle_profile","text":"<p>Create a particle profile from the parameters of Double Exponential (DEXP) current source (tdelay, tau1, tau2, q).</p> <p>Syntax:</p> <pre><code>%&gt; create_particle_profile -name &lt;name&gt; -tdelay &lt;double exponential delay&gt; -tau1 &lt;double exponential tau1&gt; -tau2 &lt;double exponential tau2&gt; -q &lt;double exponential q&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>-name</code> is the name of the particle profile</li> <li><code>-tdelay</code> is the delay till the start of the current pulse waveform</li> <li><code>-tau1</code> is the rise time of the pulse waveform</li> <li><code>-tau2</code> is the fall time of the pulse waveform</li> <li><code>-q</code> is the collected charge which is relevant to the peak current of the pulse waveform</li> </ul> <p>Example</p> <pre><code>create_particle_profile -name p1 -tdelay 0.1ns -tau1 0.1 -tau2 0.1 -q 400\n</code></pre>"},{"location":"commands_reference.html#delete_particle_profile","title":"delete_particle_profile","text":"<p>Delete a particle profile from memory.</p> <p>Syntax:</p> <pre><code>%&gt; delete_particle_profile &lt;profile_name&gt;\n</code></pre>"},{"location":"commands_reference.html#clear_particle_profiles_info","title":"clear_particle_profiles_info","text":"<p>Clear all the particle profiles stored in memory.</p> <p>Syntax:</p> <pre><code>%&gt; clear_particle_profiles_info\n</code></pre>"},{"location":"commands_reference.html#list_particle_profiles","title":"list_particle_profiles","text":"<p>List all the particle profiles stored in memory.</p> <p>Syntax:</p> <pre><code>%&gt; list_particle_profiles\n</code></pre>"},{"location":"commands_reference.html#create_set_scenario","title":"create_SET_scenario","text":"<p>Create a single SET scenario in memory. The create SET scenario will be considered when generating SET pulses. User can either define a particle profile with <code>-profile</code> parameter or by specify right away the parameters of the DEXP current source.</p> <p>Syntax:</p> <pre><code>%&gt; create_SET_scenario &lt;driver_gatepin&gt; ?&lt;endpoint&gt;? (-profile &lt;particle_profile_name&gt; | &lt;tdelay&gt;n &lt;tau1&gt;p &lt;tau2&gt;p &lt;q&gt;)\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;driver_gatepin&gt;</code> is the name of the driver gate pin</li> <li><code>&lt;endpoint&gt;</code> is the name of the endpoint gate pin (for which information is stored)</li> <li><code>&lt;particle_profile_name&gt;</code> is the name of the particle profile</li> <li><code>&lt;tdelay&gt;</code> is the delay till the start of the current pulse waveform</li> <li><code>&lt;tau1&gt;</code> is the rise time of the pulse waveform</li> <li><code>&lt;tau2&gt;</code> is the fall time of the pulse waveform</li> <li><code>&lt;q&gt;</code> is the collected charge which is relevant to the peak current of the pulse waveform</li> </ul> <p>Example</p> <p>Example 1:</p> <pre><code>create_SET_scenario SET_testcase/U25/Q 0.1n 47p 347p 700f\n</code></pre> <p>Example 2:</p> <pre><code>create_SET_scenario SET_testcase/U25/Q -profile p1\n</code></pre>"},{"location":"commands_reference.html#load_set_scenarios","title":"load_SET_scenarios","text":"<p>A scenario file consists of scenarios specifying a driver pin, an endpoint and the parameters of the Double Exponential (DEXP) current source (<code>tdelay</code>, <code>tau1</code>, <code>tau2</code>, <code>q</code>).</p> <p>Example</p> <p>Scenario file example:</p> <pre><code>module1/reg1/Q module1/reg2/D 0.5n 54p 391p 342f\nmodule2/reg1/Q module2/reg2/D 0.5n 56p 377p 367f\n</code></pre> <p>The command is used to load a scenario file in memory, which will be used to generate SET pulses in future releases.</p> <p>Syntax:</p> <pre><code>%&gt; load_SET_scenarios &lt;filename&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;filename&gt;</code> is the name of the scenario file</li> </ul>"},{"location":"commands_reference.html#list_set_scenario","title":"list_SET_scenario","text":"<p>List information for a specific SET scenario based on the specified scenario index.</p> <p>Syntax:</p> <pre><code>%&gt; list_SET_scenario &lt;scenario_index&gt;\n</code></pre>"},{"location":"commands_reference.html#list_set_scenarios","title":"list_SET_scenarios","text":"<p>List information for all the SET scenarios stored in memory.</p> <p>Syntax:</p> <pre><code>%&gt; list_SET_scenarios\n</code></pre>"},{"location":"commands_reference.html#clear_set_scenarios","title":"clear_SET_scenarios","text":"<p>Clear all the SET scenarios stored in memory.</p> <p>Syntax:</p> <pre><code>%&gt; clear_SET_scenarios\n</code></pre>"},{"location":"commands_reference.html#create_set_scenario_case_analysis","title":"create_SET_scenario_case_analysis","text":"<p>Create SET case analysis for specified scenario (<code>-scenario</code>). SET case analysis consists of a scenario index, which represents the affected scenario, a boolean constant value which is applied to specified gatepins and a list of gatepins which will be set to previously defined constant value.</p> <p>Syntax:</p> <pre><code>%&gt; create_SET_scenario_case_analysis -scenario &lt;scenario index&gt; &lt;boolean constant value&gt; {&lt;gatepin&gt;}\n</code></pre> <p>Example</p> <pre><code>%&gt; create_SET_scenario_case_analysis -scenario 0 0 buffer_tree/AND1/B\n</code></pre>"},{"location":"commands_reference.html#list_set_scenario_case_analysis","title":"list_SET_scenario_case_analysis","text":"<p>List specified SET scenario case analysis info. Use <code>-all</code> argument to list all SET scenarios\u2019 case analysis info.</p> <p>Syntax:</p> <pre><code>%&gt; list_SET_scenario_case_analysis -scenario &lt;scenario index&gt; | -all\n</code></pre>"},{"location":"commands_reference.html#clear_set_scenario_case_analysis","title":"clear_SET_scenario_case_analysis","text":"<p>Clear specified SET scenario case analysis info. Use <code>-all</code> argument to clear all SET scenarios case analysis info.</p> <p>Syntax:</p> <pre><code>%&gt; clear_SET_scenario_case_analysis -scenario &lt;scenario index&gt; | -all\n</code></pre>"},{"location":"commands_reference.html#set_static_probability","title":"set_static_probability","text":"<p>Set the logic-1 static probability value to the specified gatepin. Use -value argument to define the probability value. Note that the logic-1 and logic-0 probabilities are complementary, so only one of the two must be defined. Use -gatepin argument to define the gatepin for which the probability is set. Use -all argument to set the probability for all gatepins. Use <code>-startpoints</code> argument to set the probability for startpoint gatepins.</p> <p>Syntax:</p> <pre><code>%&gt; set_static_probability -value &lt;probability_value&gt; (-gatepin &lt;gatepin_name&gt; | -all | -startpoints)\n</code></pre> <p>Arguments:</p> <ul> <li><code>-value</code> is the static probability logic-1 value</li> <li><code>-gatepin &lt;gatepin_name&gt;</code> is the name of the gatepin for which the probability is to be set</li> <li><code>-all</code> is used to set the probability for all gatepins</li> <li><code>-startpoints</code> is used to set the probability for startpoint gatepins</li> </ul>"},{"location":"commands_reference.html#list_cubes_propagating_input_sets_to_output","title":"list_cubes_propagating_input_SETs_to_output","text":"<p>Generate a list of Boolean cubes containing the side-input values that enable the propagation of SETs from the inputs of the gate to the specified output gatepin.</p> <p>Syntax:</p> <pre><code>%&gt; list_cubes_propagating_input_SETs_to_output &lt;gatepin_name&gt; -inputSET [&lt;0 (logic-0) | 1 (logic-1) | 0e (negative SET) | 1e (positive SET) | dc (don't care)&gt; ...]\n</code></pre> <p>Arguments:</p> <ul> <li><code>inputSET</code> is the list of input SETs. Available options are 0 (logic-0), 1 (logic-1), 0e (negative SET), 1e (positive SET), dc (don't care)</li> </ul>"},{"location":"commands_reference.html#list_static_probabilities","title":"list_static_probabilities","text":"<p>Propagate and list all static probabilities stored in memory per gatepin in a column format report. Use <code>-significant_digits</code> argument to set the floating point precision in the report.</p> <p>Syntax:</p> <pre><code>%&gt; list_static_probabilities -significant_digits &lt;significant_digits&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>-significant_digits</code> is the floating point precision in the report</li> </ul>"},{"location":"commands_reference.html#reset_static_probabilities","title":"reset_static_probabilities","text":"<p>Reset static probabilities annotated by SAIF file or set by set_static_probability</p> <p>Syntax:</p> <pre><code>%&gt; reset_static_probabilities\n</code></pre>"},{"location":"commands_reference.html#set_set_generation_parameters","title":"set_SET_generation_parameters","text":"<p>Set the SET generation model and each model\u2019s parameters. Two models can be specified, Double Exponential (DEXP) or Bias Dependent (BIAS). Bias Dependent model parameters consist of the auxiliary Capacitance (<code>-biascapacitance</code>), Recombination Currents (<code>-recomb</code>) and Fermi (<code>-fermi</code>) constants. SET generation model and its parameters apply to all loaded scenarios when generate_SET_glitch or generate_SET_scenario_glitch are used to generate the SET glitch.</p> <p>Syntax:</p> <pre><code>%&gt; set_SET_generation_parameters -model &lt;DEXP | BIAS&gt; -biascapacitance &lt;BIAS capacitance&gt; -recomb &lt;recombination currents constant&gt; -fermi &lt;fermi constant&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>-model</code> is the SET generation model (Double Exponential or Bias Dependent)</li> <li><code>-biascapacitance</code> is Bias Dependent model auxilary capacitance to enure charge conservation</li> <li><code>-recomb</code> is the Bias Dependent model Recombination Currents constant</li> <li><code>-fermi</code> is the Bias Dependent model Fermi constant</li> </ul> <p>Example</p> <pre><code>%&gt; set_SET_generation_parameters -model BIAS -biascapacitance 1p -recomb 1e11 -fermi 0.01\n</code></pre>"},{"location":"commands_reference.html#generate_set_scenario_glitch","title":"generate_SET_scenario_glitch","text":"<p>Generate an SET glitch from a single scenario (<code>-scenario</code>) load in memory or from all scenarios (<code>-all</code>) loaded and store the rise and fall arrival times and slews at the receiver gatepins of the driver gatepin net.</p> <p>Syntax:</p> <pre><code>%&gt; generate_SET_scenario_glitch -scenario &lt;scenario_index&gt; | -all ?-corner &lt;corner_index&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>-scenario</code> is the scenario index to be used for the SET glitch generation</li> <li><code>-all</code> is used to generate the SET glitch for all the defined SET scenarios</li> <li><code>-corner</code> is the index of the library corner to be used for the SET glitch generation</li> </ul> <p>Example</p> <pre><code>%&gt; generate_SET_scenario_glitch -scenario 1 -corner 0\n%&gt; generate_SET_scenario_glitch -all -corner 0\n</code></pre>"},{"location":"commands_reference.html#generate_set_scenario_custom_glitch","title":"generate_SET_scenario_custom_glitch","text":"<p>Generate a SET glitch as a PWL (Piece Wise Linear) voltage waveform to a receiver gatepin and store it as a new scenario. Afterwards, the specified glitch can be propagated through propagate_SET_scenario_glitch.</p> <p>Syntax:</p> <pre><code>%&gt; generate_SET_scenario_custom_glitch -scenario &lt;receivergatepin&gt; {t0 v0 t1 v1 ... tn vn} -corner &lt;corner_index&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>-scenario</code> is the SET generation scenario, PWL Voltage Waveform at a receiver gatepin</li> <li><code>-corner</code> is the index of the library corner to be used for the SET glitch generation</li> </ul> <p>Example</p> <pre><code>%&gt; generate_SET_scenario_custom_glitch -scenario buffer_tree/U2/A {0n 0 1n 0 1.005n 0.20 1.015n 0.90 1.02n 1.08 1.09n 1.08 1.2n 0.9 1.6n 0.1 1.8n 0 3n 0} -corner 0\n</code></pre>"},{"location":"commands_reference.html#propagate_set_scenario_glitch","title":"propagate_SET_scenario_glitch","text":"<p>Propagate a SET glitch from a single scenario loaded in memory (<code>-scenario</code>) or from all scenarios loaded (<code>-all</code>). Before running this command, the SET pulse must be generated, using the command generate_SET_scenario_glitch.</p> <p>Syntax:</p> <pre><code>%&gt; propagate_SET_scenario_glitch -scenario &lt;scenario_index&gt; | -all ?-corner &lt;corner_index&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>-scenario</code> is the scenario index to be used for the SET glitch propagation</li> <li><code>-all</code> is used to propagate the SET glitch for all the defined SET scenarios</li> <li><code>-corner</code> is the index of the library corner to be used for the SET glitch propagation</li> </ul> <p>Example</p> <pre><code>%&gt; propagate_SET_scenario_glitch -scenario 1 -corner 0\n%&gt; propagate_SET_scenario_glitch -all -corner 0\n</code></pre>"},{"location":"commands_reference.html#set_set_glitch_propagation_mode","title":"set_SET_glitch_propagation_mode","text":"<p>Set the SET glitch propagation STA-mode. Three modes are available, \"Vanilla\", Detailed Timestamp-based and Bounded Timestamp-based. Each mode is described in section SET Propagation STA-modes. The default mode is \"Vanilla\".</p> <p>Syntax:</p> <pre><code>%&gt; set_SET_glitch_propagation_mode &lt;0: \"Vanilla\" STA-mode | 1: Detailed TimeStamp-based STA-mode | 2: Bounded TimeStamp-based STA-mode&gt;\n</code></pre>"},{"location":"commands_reference.html#generate_set_glitch","title":"generate_SET_glitch","text":"<p>Generate an SET glitch. The command requires specifying the SET generation scenario. The SET generation scenario consists of a specified driver pin, which represents the affected net, the endpoint where measurements are taken, and the Double Exponential Current Source (DEXP) parameters. The command created SPICE probes internally at all affected nets receivers, in order to take rise and fall arrival times and slew measurements. These probes are cleared after the glitch generation is completed. Upon completion, the command prints the calculated rise and fall arrival times and slews.</p> <p>Syntax:</p> <pre><code>%&gt; generate_SET_glitch -scenario &lt;drivergatepin&gt; &lt;endpoint&gt; &lt;tdelay&gt; &lt;tau1&gt; &lt;tau2&gt; &lt;q&gt; -corner &lt;corner_index&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>-scenario</code> is the SET generation scenario, consisting of the driver gatepin, the endpoint, and the DEXP parameters</li> <li><code>-corner</code> is the index of the library corner to be used for the SET glitch generation</li> </ul> <p>Example</p> <pre><code>%&gt; generate_SET_glitch -scenario ASU_2bufs/U1/Y ASU_2bufs/U2/A 0.1n 47p 347p 700f -corner 0\n</code></pre>"},{"location":"commands_reference.html#propagate_set_glitch","title":"propagate_SET_glitch","text":"<p>Propagate the rise (<code>-rise</code>) and fall (<code>-fall</code>) arrival times and slews from the input gatepin given as argument (<code>-gatepin</code>) to the forward logic cone.</p> <p>Syntax:</p> <pre><code>%&gt; propagate_SET_glitch -gatepin &lt;receivergatepinname&gt; -rise {risearrival_1 riseslew_1 ... risearrival_N riseslew_N} -fall {fallarrival_1 fallslew_1 ... fallarrival_N fallslew_N} ?-corner &lt;corner_index&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>-gatepin</code> is the name of the input gatepin from where the SET propagation starts</li> <li><code>-rise</code> is the list of rise arrival times and slews</li> <li><code>-fall</code> is the list of fall arrival times and slews</li> <li><code>-corner</code> is the index of the library corner to be used for the SET glitch propagation</li> </ul> <p>Example</p> <pre><code>%&gt; propagate_SET_glitch -gatepin buffer_tree/U2/A -rise {0.123118 0.052256} -fall {0.500256 0.693101}\n</code></pre>"},{"location":"commands_reference.html#set_net_supply","title":"set_net_supply","text":"<p>Set the voltage/current source supply for the specified net and define the transient specification of the supply. Supported transient specifications: Piece-Wise Linear (PWL), Double Exponential (DEXP).</p> <p>Syntax:</p> <pre><code>%&gt; set_net_supply &lt;supplyname&gt; &lt;drivergatepin&gt; &lt;groundname&gt; &lt;transientspec&gt; {&lt;transientspec args&gt;}\n</code></pre> <p>Example</p> <pre><code>%&gt; set_net_supply ISET ASU_2bufs/U1/Y 0 DEXP {{0.5n 47p 647p 282f}}\n</code></pre>"},{"location":"commands_reference.html#simulate_net","title":"simulate_net","text":"<p>Perform SPICE simulation for the specified gatepin net.</p> <p>Syntax:</p> <pre><code>%&gt; simulate_net &lt;driver_gatepin&gt;\n</code></pre>"},{"location":"commands_reference.html#set_spice_simulation_parameters","title":"set_spice_simulation_parameters","text":"<p>Specify SPICE simulation time step and total duration.</p> <p>Syntax:</p> <pre><code>%&gt; set_spice_simulation_parameters -timestep &lt;timestepvalue&gt; -totalduration &lt;totaldurationvalue&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>-timestep</code> is the transient analysis time step value</li> <li><code>-totalduration</code> is the total duration value</li> </ul>"},{"location":"commands_reference.html#create_net_spice_probe","title":"create_net_spice_probe","text":"<p>Create a probe for storing SPICE simulation data. Voltage probes are specified at a single node with reference to GND, while current probes are specified at net supplies.</p> <p>Syntax:</p> <pre><code>%&gt; create_net_spice_probe &lt;drivergatepin&gt; (-node &lt;spefnodename&gt; | -vnode &lt;voltagesourcename&gt; | -all) ?-longest | -shortest?\n</code></pre> <p>Arguments:</p> <ul> <li><code>-node</code> is the SPEF net node</li> <li><code>-vnode</code> is the voltage source name</li> <li><code>-all</code> is used to create probes at all nodes</li> <li><code>-longest</code> is used for worst case analysis</li> <li><code>-shortest</code> is used for best case analysis</li> </ul> <p>Example</p> <pre><code>5&gt; create_net_spice_probe ASU_2bufs/U1/Y -node 3:1 -longest\n</code></pre>"},{"location":"commands_reference.html#plot_spice_probe","title":"plot_spice_probe","text":"<p>Plot specified probe data. The desired probes are specified by their list index. Use the command list_spice_probes to print all spice probes and their index.</p> <p>Syntax:</p> <pre><code>%&gt; plot_spice_probe {probelist}\n</code></pre>"},{"location":"commands_reference.html#list_spice_probes","title":"list_spice_probes","text":"<p>List all the SPICE probes stored in memory.</p> <p>Syntax:</p> <pre><code>%&gt; list_spice_probes\n</code></pre>"},{"location":"commands_reference.html#perform_exhaustive_set_analysis","title":"perform_exhaustive_SET_analysis","text":"<p>Performs exhaustive SET analysis. For each defined particle profile, iterates through all output gatepins and creates an SET scenario for each one. Then, after all scenarios have been created, generation followed by propagation of the SET glitch is performed for each SET scenario.</p> <p>Syntax:</p> <pre><code>%&gt; perform_exhaustive_SET_analysis\n</code></pre>"},{"location":"commands_reference.html#perform_set_analysis","title":"perform_SET_analysis","text":"<p>Heuristic SET analysis flow. Run the SET analysis for a set of particle profiles and a set of output gatepins. For each given output gatepin a SET scenario will be created for each given particle to perform the SET analysis flow (generation &amp; propagation). This command is an alternative to perform_exhaustive_SET_analysis in case the user wants to run the analysis for specific portions of the circuit and particle profiles.</p> <p>Syntax:</p> <pre><code>%&gt; perform_SET_analysis -profiles {&lt;profile1&gt; &lt;profile2&gt; ...} -gatepins {&lt;gatepin1&gt; &lt;gatepin2&gt; ...}\n</code></pre> <p>Arguments:</p> <ul> <li><code>-profiles</code> is the list of particle profiles to be used for the SET analysis</li> <li><code>-gatepins</code> is the list of output gatepins to be used for the SET analysis</li> </ul> <p>Example</p> <pre><code>%&gt; perform_SET_analysis -profiles {p1 p2 p3} -gatepins {SET_testcase/U1/Q SET_testcase/U2/Q SET_testcase/U3/Q SET_testcase/U4/Q}\n</code></pre>"},{"location":"commands_reference.html#list_gatepins_set_analysis_info","title":"list_gatepins_set_analysis_info","text":"<p>List SET analysis information for a specific gatepin.</p> <p>Syntax:</p> <pre><code>%&gt; list_gatepins_set_analysis_info &lt;gatepin_name&gt;\n</code></pre>"},{"location":"commands_reference.html#list_all_gatepin_set_analysis_info","title":"list_all_gatepin_set_analysis_info","text":"<p>List SET analysis information for all gatepins.</p> <p>Syntax:</p> <pre><code>%&gt; list_all_gatepin_set_analysis_info\n</code></pre>"},{"location":"commands_reference.html#report_set_scenario_timingpoints","title":"report_SET_scenario_timingpoints","text":"<p>Lists for a specific scenario the timingpoints, i.e., the forward logic cone gatepins that have been traversed by the glitch.</p> <p>Syntax:</p> <pre><code>%&gt; report_SET_scenario_timingpoints &lt;scenario_index&gt;\n</code></pre>"},{"location":"commands_reference.html#report_set_generation_probabilities","title":"report_SET_generation_probabilities","text":"<p>Report positive and negative SET generations probabilities for all gatepins.</p> <p>Syntax:</p> <pre><code>%&gt; report_SET_generation_probabilities\n</code></pre>"},{"location":"commands_reference.html#eco_swap_component_pins","title":"eco_swap_component_pins","text":"<p>Rewire two input pins of a component.</p> <p>Syntax:</p> <pre><code>%&gt; eco_swap_component_pins &lt;component_name&gt; &lt;pin_name_1&gt; &lt;pin_name_2&gt;\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;component_name&gt;</code> is the name of the target component to perform rewiring</li> <li><code>&lt;pin_name_1&gt;</code> is the name of the first pin to be rewired</li> <li><code>&lt;pin_name_2&gt;</code> is the name of the second pin to be rewired</li> </ul>"},{"location":"commands_reference.html#eco_upsize_component","title":"eco_upsize_component","text":"<p>Upsize a component to the immediate larger component.</p> <p>Syntax:</p> <pre><code>%&gt; eco_upsize_component &lt;component_name&gt; ?-overlapsmethod &lt;1 | 2 | 3&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;component_name&gt;</code> is the name of the target component to upsize</li> <li><code>-overlapsmethod</code> is the overlap handling method (optional)<ul> <li><code>1</code>: remove from rows and mark as illegal only the overlapping components (default)</li> <li><code>2</code>: remove from rows and mark as illegal both the resized and the overlapping components</li> <li><code>3</code>: remove from rows and mark as illegal only the resized component</li> </ul> </li> </ul>"},{"location":"commands_reference.html#eco_downsize_component","title":"eco_downsize_component","text":"<p>Downsize a component to the immediate smaller component.</p> <p>Syntax:</p> <pre><code>%&gt; eco_downsize_component &lt;component_name&gt; ?-overlapsmethod &lt;1 | 2 | 3&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;component_name&gt;</code> is the name of the target component to downsize</li> <li><code>-overlapsmethod</code> is the overlap handling method (optional)<ul> <li><code>1</code>: remove from rows and mark as illegal only the overlapping components (default)</li> <li><code>2</code>: remove from rows and mark as illegal both the resized and the overlapping components</li> <li><code>3</code>: remove from rows and mark as illegal only the resized component</li> </ul> </li> </ul>"},{"location":"commands_reference.html#eco_charge_sharing","title":"eco_charge_sharing","text":"<p>Insert charge-sharing logic to a target gatepin.</p> <p>Syntax:</p> <pre><code>%&gt; eco_charge_sharing &lt;target_gatepin&gt; -cell &lt;delay_cell&gt; -num &lt;number_of_delay_cells&gt; ?-placementmethod &lt;0 (Default Placement) | 1 (Place in the centre-of-mass) | 2 (Place in the centre-of-mass and remove overlapping components)&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;target_gatepin&gt;</code> is the name of the target gatepin to insert charge-sharing logic</li> <li><code>-cell</code> is the name of the delay cell to be used for the charge-sharing logic</li> <li><code>-num</code> is the number of delay cells to be used for the charge-sharing logic</li> <li><code>-placementmethod</code> is the placement method (optional)<ul> <li><code>0</code>: place the new components at (0, 0) (default)</li> <li><code>1</code>: place the new components at the centre of mass</li> <li><code>2</code>: place the new components at the centre of mass and remove overlapping components</li> </ul> </li> </ul>"},{"location":"commands_reference.html#eco_fanout_decomposition","title":"eco_fanout_decomposition","text":"<p>Perform fan-out decomposition in a target component by performing gate cloning on the target component and splitting the fan-out of the target gatepin.</p> <p>Syntax:</p> <pre><code>%&gt; eco_fanout_decomposition &lt;target_component&gt; ?-placementmethod &lt;0 (Default Placement) | 1 (Place in the centre-of-mass) | 2 (Place in the centre-of-mass and remove overlapping components)&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;target_component&gt;</code> is the name of the target component to perform fan-out decomposition</li> <li><code>-placementmethod</code> is the placement method (optional)<ul> <li><code>0</code>: place the new components at (0, 0) (default)</li> <li><code>1</code>: place the new components at the centre of mass</li> <li><code>2</code>: place the new components at the centre of mass and remove overlapping components</li> </ul> </li> </ul>"},{"location":"commands_reference.html#eco_tmr_component","title":"eco_tmr_component","text":"<p>Apply Triple Modular Redundancy (TMR) to a target component. The target component is triplicated with the input of each replica being tied together and their outputs connected to a majority voter. As for the majority voter, UPSET uses the NAND based majority voter, which is shown in the figure.</p> <p>Syntax:</p> <pre><code>%&gt; eco_tmr_component &lt;component_name&gt; ?-placementmethod &lt;0 (Default Placement) | 1 (Place in the centre-of-mass) | 2 (Place in the centre-of-mass and remove overlapping components)&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;component_name&gt;</code> is the name of the target component to apply TMR</li> <li><code>-placementmethod</code> is the placement method (optional)<ul> <li><code>0</code>: place the new components at (0, 0) (default)</li> <li><code>1</code>: place the new components at the centre of mass</li> <li><code>2</code>: place the new components at the centre of mass and remove overlapping components</li> </ul> </li> </ul>"},{"location":"commands_reference.html#eco_insert_filter","title":"eco_insert_filter","text":"<p>Insert a SET filter to a target gatepin. The SET filter is composed by a guard gate and a delay line.</p> <p>Bug</p> <p>The current version of SET filter insertion is supporting the insertion of an AND gate for the voting, instead of a guard gate. However, this is not correct, since the AND gate will result in broadening negative (1-&gt;0-&gt;1) SET pulses instead of attenuating them. Thus, the SET filter insertion should be updated to support the insertion of a guard gate in the next release.</p> <p>Syntax:</p> <pre><code>%&gt; eco_insert_filter &lt;target_gatepin&gt; -cell &lt;delay_cell&gt; -num &lt;number_of_delay_cells&gt; -AND &lt;AND_cell&gt; ?-placementmethod &lt;0 (Default Placement) | 1 (Place in the centre-of-mass) | 2 (Place in the centre-of-mass and remove overlapping components)&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;target_gatepin&gt;</code> is the name of the target gatepin to insert a SET filter</li> <li><code>-cell</code> is the name of the delay cell to be used for the SET filter</li> <li><code>-num</code> is the number of delay cells to be used for the SET filter</li> <li><code>-AND</code> is the name of the AND cell to be used for the SET filter</li> <li><code>-placementmethod</code> is the placement method (optional)<ul> <li><code>0</code>: place the new components at (0, 0) (default)</li> <li><code>1</code>: place the new components at the centre of mass</li> <li><code>2</code>: place the new components at the centre of mass and remove overlapping components</li> </ul> </li> </ul>"},{"location":"commands_reference.html#eco_insert_cascaded_inverter","title":"eco_insert_cascaded_inverter","text":"<p>Insert a pair of cascaded inverters to a target gatepin.</p> <p>Syntax:</p> <pre><code>%&gt; eco_insert_cascaded_inverter &lt;target_gatepin&gt; -cells &lt;cell 1&gt; &lt;cell 2&gt; ?-placementmethod &lt;0 (Default Placement) | 1 (Place in the centre-of-mass) | 2 (Place in the centre-of-mass and remove overlapping components)&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>&lt;target_gatepin&gt;</code> is the name of the target gatepin to insert a cascaded inverter</li> <li><code>-cells</code> is the name of the INV cells to be used for the cascaded inverters</li> <li><code>-placementmethod</code> is the placement method (optional)<ul> <li><code>0</code>: place the new components at (0, 0) (default)</li> <li><code>1</code>: place the new components at the centre of mass</li> <li><code>2</code>: place the new components at the centre of mass and remove overlapping components</li> </ul> </li> </ul>"},{"location":"commands_reference.html#legalise_components","title":"legalise_components","text":"<p>Perform legalisation of the circuit components.</p> <p>Syntax:</p> <pre><code>%&gt; legalise_components -order &lt;0 (all) | 1 (increasing) | 2 (decreasing) | 3 (centre-outwards)&gt; -blockagesmethod &lt;0 (Subrow Assignment - SRA) | 1 (Subrow Reassignment - SRR)&gt; ?-timingdriven &lt;longest | shortest&gt;? ?-htmlreport &lt;filename&gt;?\n</code></pre> <p>Arguments:</p> <ul> <li><code>-order</code> is the order of the legalisation<ul> <li><code>0</code>: all of the 3 supported orders and choose the best one</li> <li><code>1</code>: increasing order of components x-coordinates</li> <li><code>2</code>: decreasing order of components x-coordinates</li> <li><code>3</code>: centre-outwards order of components x-coordinates</li> </ul> </li> <li><code>-blockagemethod</code> is the blockage method<ul> <li><code>0</code>: Subrow Assignment - SRA</li> <li><code>1</code>: Subrow Reassignment - SRR</li> </ul> </li> <li><code>-timingdriven</code> is the timing driven analysis (optional)</li> <li><code>-htmlreport</code> is the name of the HTML report file to be generated (optional)</li> </ul>"},{"location":"design_configuration.html","title":"Pre-SET Analysis Design Configuration","text":""},{"location":"design_configuration.html#step-1-import-design","title":"Step 1: Import Design","text":""},{"location":"design_configuration.html#import-lef","title":"Import LEF","text":"<p>The LEF file should include all the technology library cells present in the Verilog netlist, as LEF Macros which describe the physical dimensions for the library components. The LEF file should also include SITE declarations, i.e. placement sites which will subsequently be used to create the standard-cell rows for the placement. Also, multiple LEF files are supported. LEF file is necessary for the SET Analysis flow.</p> <p>The LEF file can be loaded either by the TCL command:</p> <pre><code>%&gt; load_lef {&lt;lef_file_&gt;}\n</code></pre> <p>or using the keystroke <code>Ctrl+L\"</code> or using the GUI menu <code>File -&gt; Load LEF Technology File</code>.</p> <p></p>"},{"location":"design_configuration.html#import-lib","title":"Import LIB","text":"<p>Liberty (LIB) library file specifies the cells that exist in the library and for each one of them, it defines attributes such as pin names, area, functionality, timing, power, etc. Multiple LIB files can be loaded, one for each operation corner. LIB file is necessary for the SET Analysis flow.</p> <p>The LIB file can be loaded either by the TCL command:</p> <pre><code>%&gt; load_lib {&lt;lib_file_&gt;} ?-errors?\n</code></pre> <p>or using the keystroke <code>Ctrl+T\"</code> or using the GUI menu <code>File -&gt; Load Timing Library LIB File</code>.</p> <p></p>"},{"location":"design_configuration.html#import-verilog","title":"Import Verilog","text":"<p>The Verilog gate-level netlist file describes the circuit connectivity, as well as the module hierarchy. The netlist should be uniquified so that each module instantiation corresponds directly and is 1-1 to a corresponding module declaration. Loading Verilog file is necessary for the SET Analysis flow.</p> <p>The Verilog netlist can be loaded either by the TCL command:</p> <pre><code>%&gt; load_verilog {&lt;verilog_file_&gt;}\n</code></pre> <p>or using the keystroke <code>Ctrl+V\"</code> or using the GUI menu <code>File -&gt; Load VERILOG Netlist</code>.</p> <p></p>"},{"location":"design_configuration.html#import-spef","title":"Import SPEF","text":"<p>Standard Parasitic Exchange Format (SPEF) is an IEEE standard for representing the parasitic data of the circuit wires, and it used for delay calculation. Non-ideal wires have parasitic resistance and capacitance, while are specified inside the SPEF file. SPEF file is optional for the SET Analysis flow, but it increases its accuracy.</p> <p>The SPEF file can be loaded for each analysis mode using TCL command:</p> <pre><code>%&gt; load_spef (-longest | -shortest) ?-errors? {&lt;spef_file_&gt;}\n</code></pre> <p>, where the flags <code>-longest</code> and <code>-shortest</code> determine that the SPEF file contains the parasitics extracted for the worst or best case analysis, respectively.</p>"},{"location":"design_configuration.html#import-saif","title":"Import SAIF","text":"<p>Switching Activity Interchange Format (SAIF) is an IEEE standard developed by Synopsys \u00a9 for capturing the toggle rate of the signals in the design and analysing its power consumption. The SAIF file is based on static probability and toggle rate:</p> <ul> <li>Static Probability: Probability that a signal is at a specific logic state. <code>P1</code> is the probability of the signal being at logic-1 and <code>P0</code> is the probability of the signal being at logic-0.</li> <li>Toggle Rate: The number of transitions of logic-0 to logic-1 and vice versa of each pin per unit of time.</li> </ul> Terminology Definition <code>T0</code> Duration of time found in logic-0 state <code>T1</code> Duration of time found in logic-1 state <code>TX</code> During of time found in unknown \"X\" state <code>TC</code> The sum of 0-&gt;1 and 1-&gt;0 transitions captured during monitoring <code>IG</code> Number of 0-&gt;X-&gt;0 and 1-&gt;X-&gt;1 glitches captured during monitoring <code>RISE</code> Rise transitions in a given state <code>FALL</code> Fall transitions in a given state <p>The above table lists some of the basic terms used in the SAIF file. From the above list, for the SET propagation, only the <code>T0</code> and <code>T1</code> terms are used. SAIF file is optional for the SET Analysis flow, and it increases the accuracy of the probabilistic SET analysis by providing more accurate static probabilities.</p> <p>The SAIF file can be loaded using the TCL command:</p> <p><pre><code>%&gt; load_saif &lt;saif_file_&gt;\n# or alternatively\n%&gt; read_saif &lt;saif_file_&gt;\n</code></pre> The information for each gatepin is stored in memory by the SAIF annotation can be reported by the TCL command:</p> <pre><code>%&gt; list_saif_info\n</code></pre>"},{"location":"design_configuration.html#step-2-tool-configuration","title":"Step 2: Tool Configuration","text":""},{"location":"design_configuration.html#select-timing-model","title":"Select Timing Model","text":"<p>UPSET timer supports two industrial models, NLDM and CCS. More details about the supported timing models can be found in section STA Timing Models. Select the design timing model using the TCL command:</p> <pre><code>%&gt; set_timing_model &lt;nldm | ccs&gt;\n</code></pre>"},{"location":"design_configuration.html#select-interconnect-timing-model","title":"Select Interconnect Timing Model","text":"<p>UPSET timer supports also three industrial models  for the modelling of the interconnect effect to the circuit timing: - Lumped RC, - Pi-model, and - Detailed RC. More details about the supported wire models can be found in section Wire Models. Select the design interconnect timing model using the TCL command:</p> <pre><code>%&gt; set_timing_RC_mode &lt;lumpedRC | pimodelRC | detailedRC&gt;\n</code></pre>"},{"location":"design_configuration.html#select-set-analysis-mode","title":"Select SET Analysis Mode","text":"<p>UPSET SET Analysis tool supports two modes: (i) Vector-based, (ii) Probabilistic. The SET analysis mode can be set using the TCL command:</p> <pre><code>%&gt; set_SET_analysis_mode &lt;0: Vector-based | 1: Probabilistic&gt;\n</code></pre>"},{"location":"design_configuration.html#step-3-sdc-constraints-specification","title":"Step 3: SDC Constraints Specification","text":""},{"location":"design_configuration.html#create-clock","title":"Create Clock","text":"<p>Synchronous designs' frequency is dictated by the use of an external clock. The period, name and waveform of this clock are specified using the SDC command:</p> <pre><code>%&gt; create_clock &lt;source_gatepin&gt; -period &lt;period_value&gt; ?-name &lt;clock_name&gt;? ?-waveform {edge_list}?\n</code></pre> <p>where:</p> <ul> <li><code>&lt;source_gatepin&gt;</code> is the name of the source gate pin of the clock</li> <li><code>&lt;period_value&gt;</code> is the period of the clock</li> <li><code>&lt;clock_name&gt;</code> is the name of the clock</li> <li><code>&lt;edge_list&gt;</code> is the waveform rise and fall edge pairs</li> </ul>"},{"location":"design_configuration.html#set-input-delay","title":"Set Input Delay","text":"<p>Input delay is the delay between a hypothetical launching sequential element in the design's environment and the design's top-level inputs. Design inputs are constrained using the SDC command:</p> <pre><code>set_input_delay &lt;delay_value&gt; ?-clock &lt;clock_name&gt;? ?-rise | -fall? ?-max | -min? ?-add_delay? {port_pin_list}\n</code></pre> <p>where:</p> <ul> <li><code>&lt;delay_value&gt;</code> is the delay value</li> <li><code>&lt;clock_name&gt;</code>specifies the hypothetical launching element clock, and therefore the input delay reference</li> <li><code>-rise</code>/<code>-fall</code> specify the delay direction</li> <li><code>-max</code> /<code>-min</code> determines the delay analysis type (worst or best case)</li> <li><code>-add_delay</code> is used to add the delay in the already stored delay value</li> <li><code>{port_pin_list}</code> is the list of input pins to be constrained</li> </ul>"},{"location":"design_configuration.html#set-output-delay","title":"Set Output Delay","text":"<p>Output delay is the delay between the specified design's top-level outputs and a hypothetical capturing sequential element in the design's environment. Design outputs are constraints using the SDC command:</p> <pre><code>%&gt; set_output_delay &lt;delay_value&gt; ?-clock &lt;clock_name&gt;? ?-rise | -fall? ?-max | -min? ?-add_delay? {port_pin_list}\n</code></pre> <p>where:</p> <ul> <li><code>&lt;delay_value&gt;</code> is the delay value</li> <li><code>&lt;clock_name&gt;</code>specifies the hypothetical capturing element clock, and therefore the output required arrival time</li> <li><code>-rise</code>/<code>-fall</code> specify the delay direction</li> <li><code>-max</code> /<code>-min</code> determines the delay analysis type (worst or best case)</li> <li><code>-add_delay</code> is used to add the delay in the already stored delay value</li> <li><code>{port_pin_list}</code> is the list of output pins to be constrained</li> </ul>"},{"location":"design_configuration.html#step-4-static-timing-analysis-sta","title":"Step 4: Static Timing Analysis (STA)","text":"<p>Timing analysis is performed to guarantee worst-case or best-case timing is met, based on the specified SDC constraints. To perform STA, use the TCL command:</p> <pre><code>%&gt; report_timing ?-longest | -shortest -corner &lt;corner_index&gt;? ?-backannotate?\n</code></pre> <p>where:</p> <ul> <li><code>-longest</code> and <code>-shortest</code> is used to determine the delay analysis type (worst or best case)</li> <li><code>-corner</code> is used to select the library corner to be used for the STA timing analysis</li> <li><code>-backannotate</code> is used to perform slack annotation for all the circuit gatepins.</li> </ul> <p>Info</p> <p>For performance reasons, slack is checked only at the timing paths endpoints. Use argument <code>-backannotate</code> to calculate global slack.</p> <p>The default command arguments are:</p> <pre><code>%&gt; report_timing -longest -corner 0\n</code></pre>"},{"location":"design_configuration.html#sta-timing-models","title":"STA Timing Models","text":"<p>Timing models are framework to accurately predict and analyse, under different conditions, how signals are transformed when they are propagated through the transistor inside the physical layout of each logic gate of a technology. More specifically, these models provide an estimation of the delay and slew at the output pin of the gate. Notably, this estimation is directly related with the signal transition at the related input pins and the load the output pin drives.</p> <p>Various timing models have been proposed in the literature. However, in recent times, the Non-Linear Delay Model (NLDM) and the Composite Current Source (CCS) have emerged as the industry standards.</p> Non-Linear Delay Model (NLDM)Composite Current Source (CCS) <p>The Non-Linear Delay Model (NLDM) is a widely used timing model in digital circuit design that provides a detailed representation of the delay and transition characteristics of the logic gates.  NLDM relies on 2D lookup tables (LUTs) to store the delay and output transition times for different combinations of input transition times and output load capacitances. These tables are generated through detailed characterisation of each logic gate under various conditions. This methods provides a significant improvement in accuracy over linear models, as it accounts the complex non-linear behavior observed in real circuits.</p> <p>Example</p> <p>Below is an example of NLDM LUTs for an output pin <code>OUT</code>. More specifically, it presents the rise delay and rise transition of the timing arc from input pin <code>INP1</code> to output pin OUT. The arc is negative unate meaning that for a rise to occur in the output, the signal at input pin INP1 must be falling. The indices from input transition times (<code>index_1</code>) and output capacitances (<code>index_2</code>) specify the values along the two dimensions of the table: input transitions (0.1, 0.3, 0.7) and output loads (0.16, 0.35, 1.43). The <code>values</code> block then provides the corresponding delay times for each combination of these indices in a matrix format. For example, in the <code>cell_rise</code> table, the delay for an input transition time of 0.3 and an output capacitance of 0.35 is found by location the second row and second column in the <code>values</code> matrix, yielding 0.2327. This method allows for precise interpolation of delay times based on given input and output conditions.</p> <pre><code>pin (OUT) {\n    max_transition : 1.0;\n    timing() {\n        related_pin : \"INP1\";\n        timing_sense : negative_unate;\n        cell_rise(delay_template_3x3) {\n            index_1 (\"0.1, 0.3, 0.7\"); /* Input transition */\n            index_2 (\"0.16, 0.35, 1.43\"); /* Output capacitance */\n            values ( /* 0.16       0.35        1.43 */\n            /* 0.1 */ \"0.0513,    0.1537,    0.5280\",\n            /* 0.3 */ \"0.1018,    0.2327,    0.6476\",\n            /* 0.7 */ \"0.1334,    0.2973,    0.7252\");\n        }\n        rise_transition(delay_template_3x3) {\n            index_1 (\"0.1, 0.3, 0.7\"); /* Input transition */\n            index_2 (\"0.16, 0.35, 1.43\"); /* Output capacitance */\n            values ( /* 0.16       0.35        1.43 */\n            /* 0.1 */ \"0.0417,    0.1337,    0.4680\",\n            /* 0.3 */ \"0.0718,    0.1827,    0.5676\",\n            /* 0.7 */ \"0.1034,    0.2173,    0.6452\");\n        }\n    }\n}\n</code></pre> <p>One of the key benefits of using NLDM is its balance between accuracy and computational efficiency. While it offers a detailed representation of the timing behavior, it does so with a manageable amount of data, making it suitable for use in large-scale digital designs. The interpolation approach used by NLDM ensures that the timing analysis remains efficient, which is particularly important in modern design flows.</p> <p>However, the accuracy of NLDM is limited by its reliance on pre-characterised data and interpolation. As process technologies advance to smaller nodes, additional factors such as complex waveform shapes and parasitic effects become more significant. Despite these limitations, NLDM remains a fundamental tool in the timing analysis of digital circuits, offering a practical and effective means of ensuring reliable circuit performance.</p> <p>The Composite Current Source (CCS) model is an advanced timing and noise modeling approach used in digital circuit design to achieve high accuracy in the timing and reliability analysis of logic cells. Unlike traditional models that primarily focus on voltage-based delay and transition times, CCS models the current behavior of a logic cell. By treating the cell as a current source, CCS captures the detailed shape of the current waveforms, which allows for more precise predictions of delays and signal integrity under various conditions. This is especially crucial for advanced process nodes.</p> <p>The CCS model is divided into two main components: - CCS Timing: Focuses on the accurate prediction of delay and transition times by considering the current profile profiles of the cell. This involves detailed characterisation of the cell's response to different input transitions and  output loading conditions. - CCS Noise: Deals with the way noise propagates through the circuit and affects signal integrity. By modeling the noise as a function of current waveforms, the CSS Noise component provides insights into how susceptible a circuit is to various noise sources, which is essential for ensuring robust operation in noisy environments.</p> <p>A significant advantage of the CCS model is its ability to provide accurate timing analysis in the presence of complex interconnect effects and noise phenomena. It captures the impact of input slew rates, output loads and power supply variations on the cell's timing behavior by representing the current flow during switching events. The level of detail helps in predicting how the logic cells will interact with each other in a real beneficial for deep sub-micron technologies, where traditional models might fall short in capturing all relevant effects.</p> <p>Implementing CCS  in STA tool involves using current waveform tables similar to NLDM using delay tables. These tables provide a rich set of data that allows for interpolation based on actual operation conditions. The current profiles are used to simulate the behavior of the cells more accurately than voltage-based models. While this approach increases the complexity and computational requirements of the analysis, it significantly enhances the accuracy of timing predictions and noise analysis.</p> <p>Example</p> <p>Below is presented an example of CCS lookup table for an output pin OUT. Similarly to NLDM LUTs, CCS LUTs are organised in timing arcs. Here, instead of rise/fall delay and transition tables, the output charging current is provided in the form of a waveform. Attributes <code>index_1</code> and <code>index_2</code> refer to the input transition and output capacitance, respectively. <code>reference_time</code> indicates the time when the input waveform cross the delay threshold voltage. The current waveform is given by <code>index_3</code> and <code>values</code> attributes, where <code>index_3</code> corresponds to the time point of the waveform and <code>values</code> to the output current at each tome point. For example, at a time of 5.079e+00 relative to the reference time, the output charging current is -5.784e-02.</p> <pre><code>pin (OUT) {\n    timing () {\n        related_pin : \"IN\"-;\n        ...\n        output_current_fall () {\n            vector (\"LOOKUP_TABLE_1x1x5\") {\n                reference_time : 5.06; /* Time of input crossing threshold */\n                index_1(\"0.040\"); /* Input transition */\n                index_2(\"0.900\"); /* Output capacitance */\n                index_3(\"5.079e+00, 5.093e+00, 5.152e+00,\n                        5.170e+00, 5.352e+00\"); /* Time values */\n                /* Output charging current: */\n                values(\"-5.784e-02, -5.980e-02, -5.417e-02,\n                        -4.257e-02, -2.184e-03\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"design_configuration.html#wire-models","title":"Wire Models","text":"<p>In advanced technology nodes, interconnect parasitics play a critical role in determining the performance, power and reliability of the circuits. As device geometries shrink, and operating frequencies increase, the resistance and capacitance of interconnects become more noticeable, affecting the overall signal propagation time. Hence, accurate wire delay estimation is crucial in modern STA engines because it ensures that the timing analysis reflects realistic conditions, allowing designers to identify and mitigate potential timing violations that could lead to functional failures.</p> <p>Several wire models have been proposed in the literature aiming to estimate wire delay, each varying in complexity and precision. Below are described the wire delay estimation models that are adopted by the UPSET STA engine.</p> Lumped RCPi-Model RCDetailed RC <p></p> <p>The Lumped RC model is the simplest form of wire delay estimation. In this model, the entire resistance (R) and capacitance (C) of an interconnect segment are lumped into a single resistor and capacitor, as shown in the next figure. This model is computationally efficient and provides a quick estimation of delay. However, it is often overly simplistic for complex designs, as it does not account for the distributed nature of resistance and capacitance along the wire. The Lumped RC model is most useful for initial approximations and in scenarios where the interconnect lengths are relatively short, and the distribution effects are minimal.</p> <p></p> <p>The Pi model offers a more refined approach compared to the Lumped RC model by diving the wire's capacitance into two segments, one at each end of the resistor, as shown in the next figure. This division allows for a more accurate representation of the wire's electrical behavior, particulaly for medium-length interconnects. The Pi model captures the effect of the distributed capacitance between than the Lumped RC model, providing a more precise delay estimation while still maintaining relatively low computational efficiency, making it a popular choice in STA tools for intermediate-level analysis.</p> <p>The Detailed, or distributed RC, model is the most accurate method for wire delay estimation. This model treats the interconnect as a series of small segments, each with its own resistance and capacitance, as shown in the next figure. The delay is calculated by integrating the effects of these small segments along the entire length of the wire. This approach captures the distributed nature of interconnect's electrical properties, providing a highly precise delay estimation. However, it is computationally intensive, requiring sophisticated algorithms and significant processing power. It is typically used in the final design stages or for critical paths where high accuracy is necessary.</p> <p></p>"},{"location":"docker_setup.html","title":"Getting Started with UPSET in Docker","text":"<p>This section explains the used docker filesystem while also act as a guide on how to build and use UPSET in a docker container.</p>"},{"location":"docker_setup.html#requirements","title":"Requirements","text":"<ul> <li>Folder containing precompiled UPSET (for Ubuntu 20.04) and the static libraries - INSTALL folder<ul> <li>Download it from GitHub here</li> </ul> </li> <li>Docker</li> <li>X11</li> <li>Machine with x86_64 architecture</li> </ul> <p>Warning</p> <p>The docker image is built for x86_64 architecture. If you are using a different architecture, please contact us at our mail for further assistance.</p>"},{"location":"docker_setup.html#top-folders","title":"Top Folders","text":"Name Description create_docker Includes repositories for CentOS 7, Dockerfile Makefile and script that runs with docker container. This folder is used to create docker image data Shared folder between host and virtual machine. Includes INSTALL folder. This folder can be used to access designs and/or scripts for UPSET use_docker Contains Makefile and a pre-built docker image. This folder is used to run the specific docker image"},{"location":"docker_setup.html#build-docker-image","title":"Build Docker Image","text":"Command Description <code>&gt; mkdir data</code> Create the data folder <code>&gt; cd data</code> Go to data folder <code>&gt; cp -r &lt;INSTALL folder&gt; ./</code> Copy the desired INSTALL folder <code>&gt; cd ../create_docker</code> Go to create_docker folder <code>&gt; make build-docker</code> Build the docker image <p>Info</p> <p>The INSTALL folder is the folder containing the UPSET executable and the static libraries. You can download it from here.</p> <p>Warning</p> <p>Version 1.0.0 of UPSET is not compatible with the docker setup, since it was built for CentOS 7. All versions of UPSET after that are built for Ubuntu 20.04 and are compatible with the docker setup.</p>"},{"location":"docker_setup.html#run-docker-image","title":"Run Docker Image","text":"Command Description <code>&gt; cd ../use_docker</code> Go to use_docker folder <code>&gt; make run</code> Run the docker container <code>&gt; make sh</code> Run in different terminal if container is already running without terminating it [optional] <p>Warning</p> <p>Running <code>make run</code> on different terminal will remove the current container and will start a new one. If you want to run on different terminal then use <code>make sh</code>. Also, running <code>make sh</code> without prior <code>make run</code> will not work.</p>"},{"location":"docker_setup.html#dockervm-filesystem","title":"Docker/VM Filesystem","text":"Folder Description <code>/home</code> Home <code>/home/data/&lt;INSTALL folder&gt;</code> UPSET folder <code>/home/data</code> Data (Shared) Folder"},{"location":"reference_card.html","title":"Supported TCL Commands","text":"Command Description Leaving UPSET quit Quit UPSET tool Import Files load_lef Load LEF technology file load_lib Load LIB Timing Library file load_verilog Load Verilog netlist load_spef Load parasitics SPEF file load_saif / read_saif Load Switching Activity (SAIF) file Tool Configuration set_timing_model Select timing model set_timing_RC_mode Select interconnect timing model Set Simulation Parameters set_spice_simulation_parameters Set SPICE simulation parameters SDC Constraints create_clock Create clock set_input_delay Set design input delay constraint set_output_delay Set design output delay constraint Static Timing Analysis report_timing Perform STA Components Legalisation legalise_components Legalise the components of the circuit removing overlaps and aligning components to power rails Simulation set_net_supply Create a SPICE supply simulate_net Perform SPICE simulation SET Generation generate_SET_glitch Generate SET glitch and report rise and fall edges slew and arrivals create_particle_profile Create a particle profile delete_particle_profile Delete specified particle profile clear_particle_profiles_info Clear all particle profiles information list_particle_profiles List all particle profiles info list_cubes_propagating_input_SETs_to_output List all cubes propagating input SETs to output create_SET_scenario Create a SET scenario load_SET_scenarios Load SET scenario file list_SET_scenarios List specified SET scenario information list_SET_scenarios List all stored SET scenarios information clear_SET_scenarios Remove all stored SET scenarios generate_SET_scenario_glitch Generate SET glitch for the specified scenario or all scenarios loaded in memory set_SET_generation_parameters Set SET generation model. For BIAS model capacitance Cs, Recombination Currents and Fermi constants parameters can be specified generate_SET_scenario_custom_glitch Generate SET glitch scenario as a PWL voltage waveform for the specified receive gatepin Nodes Measurements create_net_spice_probe Create a SPICE probe for the specified net plot_spice_probe Plot the specified probe data SET Propagation propagate_SET_glitch Propagate SET glitch and report measurements propagate_SET_scenario_glitch Propagate SET glitch for the specified scenario or all scenarios loaded in memory set_SET_glitch_propagation_mode Set SET glitch propagation mode. \"Vanilla\" mode is represented as 0, Detailed TimeStamp-based as 1, and Bounded TimeStamp-based as 2 set_SET_analysis_mode Set SET analysis mode. Vector-based is represented as 0, and Probabilistic as 1 perform_SET_analysis Perform fast SET analysis for the specified gatepins or all gatepins loaded in memory perform_exhaustive_SET_analysis Perform exhaustive SET analysis, i.e. for all circuit gatepins and particle profiles combinations Logical Masking create_SET_scenario_case_analysis Create SET scenario case analysis list_SET_scenario_case_analysis List SET scenario case analysis information clear_SET_scenario_case_analysis Remove SET scenario case analysis information Static Probabilities list_saif_info List SAIF information set_static_probability Set the static probability value for the specified gatepin(s) reset_static_probabilities Reset static probabilities list_static_probabilities Propagate and list static probabilities stored in memory Component Sensitivity Metrics list_gatepin_set_analysis_info List SET analysis information for the specified gatepin list_all_gatepin_set_analysis_info List SET analysis information for all gatepins report_SET_scenario_timingpoints Report SET scenario timingpoints report_SET_generation_probabilities Report SET generation probabilities for all gatepins ECO SET Mitigation Techniques eco_swap_component_pins Rewire two input pins of a component eco_upsize_component Upsize a component to the immediate larger component eco_downsize_component Downsize a component to the immediate smaller component eco_charge_sharing Insert charge-sharing logic to a target gatepin eco_fanout_decomposition Perform fan-out decomposition in a target component eco_tmr_component Apply Triple Modular Redundancy (TMR) to a target component eco_insert_filter Insert a SET filter to a target gatepin eco_insert_cascaded_inverter Insert a pair of cascaded inverters to a target gatepin"},{"location":"set_analysis_flow.html","title":"UPSET SET Analysis Flow","text":"<p>The UPSET SET Analysis Flow is shown below.</p> <p> </p> UPSET SET Analysis Flow"},{"location":"set_analysis_flow.html#particle-profile-definition","title":"Particle Profile Definition","text":"<p>A particle strike is simulated by default by the Double Exponential (DEXP) current source model which requires the following parameters:</p> Parameter Description <code>tdelay</code> the delay till the start of the current pulse waveform <code>tau1</code> the rise time of the pulse waveform <code>tau2</code> the fall time of the pulse waveform <code>q</code> the collected charge which is relevant to the peak current of the pulse waveform <p>The aforementioned parameters describe the characteristics of the particle strike and define a particle profile. A particle profile can be defined using the TCL command:</p> <pre><code>%&gt; create_particle_profile -name &lt;profile_name&gt; -tdelay &lt;tdelay_value&gt; -tau1 &lt;tau1_value&gt; -tau2 &lt;tau2_value&gt; -q &lt;q_value&gt;\n</code></pre> <p>where:</p> <ul> <li><code>&lt;profile_name&gt;</code> is the name of the particle profile</li> <li><code>&lt;tdelay_value&gt;</code> is the delay till the start of the current pulse waveform</li> <li><code>&lt;tau1_value&gt;</code> is the rise time of the pulse waveform</li> <li><code>&lt;tau2_value&gt;</code> is the fall time of the pulse waveform</li> <li><code>&lt;q_value&gt;</code> is the collected charge which is relevant to the peak current of the pulse waveform</li> </ul> <p>The defined particle profiles can be reported using the TCL command:</p> <pre><code>%&gt; list_particle_profiles\n</code></pre> <p>The specified particle profile(s) can be cleared from the memory using the TCL commands:</p> <pre><code># Delete a single particle profile\n%&gt; delete_particle_profile &lt;profile_name&gt;\n# Delete all the defined particle profiles\n%&gt; clear_particle_profiles_info\n</code></pre> <p>Danger</p> <p>When deleting a particle profile, the associated SET scenarios are also deleted.</p>"},{"location":"set_analysis_flow.html#set-scenarios-definition","title":"SET Scenarios Definition","text":"<p>The defined particle profiles can be used to define a SET scenario. A particle profile combined with a driver pin (and optionally an endpoint) defines a SET scenario. However, instead of a particle profile, the user can specify right away the parameters of the DEXP current source. In that case a new particle profile with these parameters is defined automatically.</p> <p>Note</p> <p>In case a particle profile with the same DEXP parameters is already defined, then the existing particle profile is associated with the defined SET scenario.</p> <p>Defining a scenario in memory can be done using the TCL command:</p> <pre><code>%&gt; create_SET_scenario &lt;driver_pin&gt; ?&lt;endpoint&gt;? -profile (&lt;particle_profile_name&gt; | &lt;tdelay&gt; &lt;tau1&gt; &lt;tau2&gt; &lt;q&gt;)\n</code></pre> <p>where:</p> <ul> <li><code>&lt;driver_pin&gt;</code> is the name of the driver pin</li> <li><code>&lt;endpoint&gt;</code> is the name of the endpoint pin (for which information is stored)</li> <li><code>&lt;particle_profile_name&gt;</code> is the name of the particle profile</li> <li><code>&lt;tdelay&gt;</code> is the delay till the start of the current pulse waveform</li> <li><code>&lt;tau1&gt;</code> is the rise time of the pulse waveform</li> <li><code>&lt;tau2&gt;</code> is the fall time of the pulse waveform</li> <li><code>&lt;q&gt;</code> is the collected charge which is relevant to the peak current of the pulse waveform</li> </ul> <p>To load many scenarios at once, a scenario file can be used which contains the designs number of SET scenarios.</p> <p>Example</p> <p>Scenario file example:</p> <pre><code>module1/reg1/Q module1/reg2/D 0.5n 54p 391p 342f\nmodule2/reg1/Q module2/reg2/D 0.5n 56p 377p 367f\n</code></pre> <p>Loading a scenario file can be done using the TCL command:</p> <pre><code>%&gt; load_SET_scenarios &lt;scenario_file&gt;\n</code></pre> <p>For a more accurate SET generation the Bias Dependent (BIAS) model can be used. More details about the supported models can be found in section SET Glitch Generation.</p> <p>The information stored for the defined SET scenarios can be reported by the TCL commands:</p> <pre><code># Report for a Single SET Scenario\n%&gt; list_SET_scenario &lt;scenario_index&gt;\n# Report for all defined SET Scenarios\n%&gt; list_SET_scenarios\n</code></pre> <p>The defined SET scenarios can be cleared from the memory using the TCL commands:</p> <pre><code># Delete a single SET scenario\n%&gt; clear_SET_scenario &lt;scenario_index&gt;\n# Delete all the defined SET scenarios\n%&gt; clear_SET_scenarios\n</code></pre>"},{"location":"set_analysis_flow.html#set-analysis","title":"SET Analysis","text":"<p>UPSET's SET analysis flow performs SET generation and propagation for the defined SET scenarios, considering also the analysis mode and the state of the circuit, specified by the user.</p>"},{"location":"set_analysis_flow.html#circuit-state-definition","title":"Circuit State Definition","text":"<p>UPSET supports two SET Analysis modes : (i) Vector-based, and (ii) Probabilistic (see also Select SET Analysis Mode section). In Vector-based SET Analysis, the state of the circuit can be defined creating SET Case Analysis, specifying values to circuit gatepins. In contrast, performing Probabilistic SET Analysis, the circuit ste is defined by annotating its gatepins with their static probabilities, i.e. probabilities for each circuit node being at logic-0 and logic-1 value.</p> SET Case AnalysisStatic Probabilities Annotation <p>By creating a SET case analysis the user defines the values for the gates' side inputs. This is supported only when SET scenarios are stored in memory and can be created using the TCL command:</p> <pre><code>%&gt; create_SET_scenario_case_analysis -scenario &lt;scenario_index&gt; &lt;boolean constant value&gt; {&lt;gatepins&gt;}\n</code></pre> <p>where:</p> <ul> <li><code>&lt;scenario_index&gt;</code> is the index of the SET scenario</li> <li><code>&lt;boolean constant value&gt;</code> is the value to be assigned to the gatepins</li> <li><code>{&lt;gatepins&gt;}</code> is the list of gatepins to be assigned the value</li> </ul> <p>The information of the case analyses created for a specified SET scenarios or all the SET scenarios stored in memory can be listed by the TCL command:</p> <pre><code>%&gt; list_SET_scenario_case_analysis -scenario &lt;scenario_index&gt; | -all\n</code></pre> <p>where:</p> <ul> <li><code>&lt;scenario_index&gt;</code> is the index of the SET scenario</li> </ul> <p>, while the case analysis created for a single SET scenario or all the SET scenarios can be cleared using the TCL command:</p> <pre><code>%&gt; clear_SET_scenario_case_analysis -scenario &lt;scenario_index&gt; | -all\n</code></pre> <p>Warning</p> <p>The Vector-based SET analysis mode is not supported in the automated SET analysis flows presented in this document, probabilistic one was recommended. This can be supported in a future release upon request.</p> <p>Alternatively to creating a case analysis for each SET scenario, the current state of the circuit be be defined by the static probabilities for each circuit pin. A static probability for a pin <code>i</code> (\\(P_i\\)) is the probability of the pin being at the logic-1 state. The static probabilities for circuit pins can be annotated either by loading a SAIF file (as shown in section Import SAIF section) or by using the TCL command:</p> <pre><code>%&gt; set_static_probability -value &lt;probability_value&gt; (-gatepin &lt;gatepin_name&gt; | -all | -startpoints)\n</code></pre> <p>where:</p> <ul> <li><code>&lt;probability_value&gt;</code> is the static probability value</li> <li><code>-gatepin &lt;gatepin_name&gt;</code> is the name of the gatepin for which the probability is to be set</li> <li><code>-all</code> is used to annotate all the circuit gatepins with the given static probability</li> <li><code>-startpoints</code> is used to annotate only the start points, i.e. Primary Inputs (PIs) and sequential elements output pins, of the circuit with the given static probability</li> </ul> <p>However, in case of Probabilistic SET analysis all the circuit gatepins must be annotated with a static probability. Thus, based on the annotated probabilities, the probabilities for the gatepins of the forward logic cone are computed using 0-Algorithm, as it was described by Parker nad McCluskey.</p> <p>The computation of static probabilities for the non-annotated gatepins can be done using the TCL command:</p> <pre><code>%&gt; list_static_probabilities -significant_digits &lt;significant_digits&gt;\n</code></pre> <p>Info</p> <p>For the static probabilities computation, it is required all the starting points of the circuit to be annotated with a static probability. In case a starting point is not annotated, a static probability of 50% is assigned to it.</p> Logic Gate Probability Equation AND2 \\(P_{out} = P_a * P_b\\) OR2 \\(P_{out} = P_a + (1 - P_a) * P_b\\) NAND2 \\(P_{out} = (1 - P_a) + P_a * (1 - P_b)\\) NOR2 \\(P_{out} = (1 - P_a) * (1 - P_b)\\) XOR2 \\(P_{out} = (1 - P_a) * P_b + P_a * (1 - P_b)\\) XNOR2 \\(P_{out} = (1 - P_a) * (1 - P_b) + P_a * P_b\\) INV \\(P_{out} = 1 - P_{a}\\) BUF \\(P_{out} = P_{a}\\) <p>The reset of static probabilities to 0 for the annotated gatepins (either by SAIF or by user-defined annotation) is done using the TCL command:</p> <pre><code>%&gt; reset_static_probabilities\n</code></pre>"},{"location":"set_analysis_flow.html#set-glitch-generation","title":"SET Glitch Generation","text":""},{"location":"set_analysis_flow.html#set-generation-models","title":"SET Generation Models","text":"<p>As mentioned in the Particle Profile Definition section, two SET Generation models can be used, either the Double Exponential (DEXP) model or the Bias Dependent (BIAS) model.</p> Double Exponential (DEXP) Current Source ModelBias Dependent (BIAS) Current Source Model <p>The Double Exponential is the default mode to model a particle strike. It simulates the strike as a current insertion through an independent current source, <code>ISET</code>, and generates a SET current pulse as shown in the figure below. However, if the generated current exceeds the driving current of the restoring transistor, the form of the current pulse may diverge from the shown double-exponential one (in case of a high LET particle strike). As a result, the typical DEXP current model cannot reproduce the the SET current pulse in case of a high LET particle strike, resulting in a voltage overshoot beyond the power supply.</p> <p> </p> <p>In case of a high LET particle strike, the generated current exceeds the driving current of the restoring transistor, and thus the form of the current pulse may diverge from the double-exponential one. As shown in figure below, the generated current pulse will have a short spike followed by a long plateau zone. The amplitude of the plateau is equal to the driving current of the restoring transistor, while the duration of the plateau increases with teh particle LET.</p> <p>The Bias Dependent model can manage the voltage overshoot effect, observed in the Double Exponential model. As illustrated in the figure below, this model implementation comprises a capacitor <code>Cs</code>, one independent current source <code>ISET</code>, and two voltage-dependent current sources, <code>GREC</code> and <code>GSEE</code>. The <code>ISET</code> is the typical DEXP current source, while the <code>GREC</code> and <code>GSEE</code> current sources are related to the recombination process and the node voltage variation due to the particle charge. The capacitor <code>Cs</code> stores the charge which is equivalent to the SET-induced charge. <code>GSEE'</code> is 1-1 with <code>GSEE</code> and is connected to driver gatepin's spefnet. Bias-dependent auxiliary net is detached from the driver gatepin's spefnet to avoid external influences that may lead to erroneous charge collection as <code>Cs</code>. <code>GREC</code> is related to the <code>Recombination Current</code> parameter. <code>GSEE</code> is dependent on <code>Cs</code> voltage and on the driver's node voltage, through the following equation:</p> \\[ \\begin{align} GSEE &amp;= (V(Cs)/tau1) \\times (1.0/(1.0 + exp((V(driver) + 3\\times F)/F))) \\\\ \\end{align} \\] <p> </p>"},{"location":"set_analysis_flow.html#glitch-generation","title":"Glitch Generation","text":"<p>The SET generation model and BIAS model parameters (<code>Cs</code>,<code>Recombination Current</code>, and <code>Fermi</code>) can be specified using the TCL command:</p> <pre><code>%&gt; set_SET_generation_parameters -model &lt;DEXP | BIAS&gt; -biascapacitance &lt;BIAS capacitance&gt; -recomb &lt;recombination current&gt; -fermi &lt;fermi constant&gt;\n</code></pre> <p>Upon creation of SET scenarios, the SET glitch can be generated for a scenario stored in memory or for all the defined SET scenarios. This can be done using the TCL command:</p> <pre><code>%&gt; generate_SET_glitch (-scenario &lt;scenario_index&gt; | -all) ?-corner &lt;corner_index&gt;?\n</code></pre> <p>where:</p> <ul> <li><code>-scenario &lt;scenario_index&gt;</code> is the index of the SET scenario for which the SET glitch is to be generated</li> <li><code>-all</code> is used to generate the SET glitch for all the defined SET scenarios</li> <li><code>-corner &lt;corner_index&gt;</code> is the index of the library corner to be used for the SET glitch generation</li> </ul>"},{"location":"set_analysis_flow.html#loading-custom-voltage-glitch","title":"Loading Custom Voltage Glitch","text":"<p>Alternative to performing SET generation, UPSET allows the user to perform SET generation in another tool (like SPICE) and store the generated voltage waveforms into a SET scenario. This can be done using the TCL command:</p> <pre><code>%&gt; generate_SET_scenario_custom_glitch -scenario &lt;receivergatepin&gt; {t0 v0 t1 v1 ... tn vn} -corner &lt;corner_index&gt;\n</code></pre> <p>where:</p> <ul> <li><code>&lt;receivergatepin&gt;</code> is the name of the receiver gate pin</li> <li><code>{t0 v0 t1 v1 ... tn vn}</code> is the list of the voltage waveform timepoints and values.</li> </ul>"},{"location":"set_analysis_flow.html#set-glitch-propagation","title":"SET Glitch Propagation","text":"<p>After the SET glitch generation at the output gatepin of the driver gate, the SET glitches are stored at the connected input gatepins of the receiver gates. The generated SET glitches need to be propagated to the forward logic cone  until they reach the end points, i.e. primary outputs or sequential elements inputs, or become masked either by logical or electrical masking.</p> <p></p> <p>Propagation of the generated SETs to the forward logic cone</p> <p>After SET scenarios have been loaded in memory (check create_SET_scenario and load_SET_scenarios commands), and SET glitch generation has been performed for a specific scenario or for all of them (check generate_SET_glitch command), then SET propagation can be performed for the scenario that SET generation has been performed or for all of them, using the TCL command:</p> <pre><code>%&gt; propagate_SET_scenario_glitch (-scenario &lt;scenario_index&gt; | -all) ?-corner &lt;corner_index&gt;?\n</code></pre> <p>where:</p> <ul> <li><code>-scenario &lt;scenario_index&gt;</code> is the index of the SET scenario for which the SET glitch propagation is to be performed</li> <li><code>-all</code> is used to propagate the SET glitch for all the defined SET scenarios</li> <li><code>-corner &lt;corner_index&gt;</code> is the index of the library corner to be used for the SET glitch propagation</li> </ul>"},{"location":"set_analysis_flow.html#set-propagation-sta-modes","title":"SET Propagation STA-modes","text":"SET pulse decomposition to its rise and fall arrival times and slews <p>A SET glitch in UPSET is characterised by the arrival time and the slew of its rise and fall edge, as shown in the next . Thus, during the SET glitch propagation, the rise and fall arrival times and slews, stored at the receivers' input gatepins are propagated to the forward logic cone by UPSET's STA engine. UPSET SET propagation supports three STA-modes: (i) \"Vanilla\" STA-mode, (ii) Detailed TimeStamp-based STA-mode, and (iii) Probabilistic STA-mode.</p> <p>The SET propagation STA-mode can be set using the TCL command:</p> <pre><code>%&gt; set_SET_glitch_propagation_mode &lt;0: Vanilla STA-mode | 1: Detailed TimeStamp-based STA-mode | 2: Bounded TimeStamp-based STA-mode&gt;\n</code></pre>"},{"location":"set_analysis_flow.html#vanilla-sta-mode","title":"\"Vanilla\" STA-mode","text":"<p>The \"Vanilla\" STA-mode performs MAX analysis without considering the gates' Boolean function. In more detail, after the generation of a SET pulse at the struct gate, the SET pulse will propagate to the forward logic cone, traversing unate (positive or negative) gate and/or binate gates.</p> <p>As for the unate gates, if the side inputs are not at a controlling logic value, the SET pulse will be propagated to the gate's output pin. The direction of the output SET pulse depends on the direction of the input SET pulse and the unateness of the gate, as shown in the figure below. In case the side input is at the controlling logic value, then the SET pulse is logically masked, and its propagation to the forward logic cone is stopped.</p> SET Propagation through unate gates SET Propagation through a positive unate gate SET Propagation through a negative unate gate <p></p> SET propagation through a binate gate results in two independent SET pulses at the output of the gate <p>As for the binate gates, like XOR or XNOR, the gate unateness, and thus the direction of the output SET pulse, depends on the value of the side input. In the \"Vanilla\" STA-mode, since it doesn't perform Boolean evaluation at the gate level, the value of the side inputs is not considered during the evaluation of the output SET pulse. Thus, as shown in the next figure, two SET cases are generated at the output of the gate, one SET with positive direction and one with negative direction.</p> <p>Table below summarises the output SET pulse cases generated when a SET pulse reaches only one input of a gate (non-reconvergence).</p> Non-Reconvergence Output SET Pulse Cases for \"Vanilla\" STA-mode Positive Unate 1 Output SET Pulse Produced The output SET pulse has the same direction with the input SET pulse Negative Unate 1 Output SET Pulse Produced The output SET pulse has the opposite direction of the input SET pulse Binate 2 Output SET Pulses Produced <sup>1</sup> Regardless the input SET pulse direction, both positive and negative SET pulse will be produced at the output pin <ol> <li><p>Binate gates produce both positive and negative SET pulse at the output due to unknown side input values.</p> </li> </ol> <p>However, during the SET pulse propagation to the forward logic cone a reconvergence point is likely to be reached. A reconvergence point is a gate where two or more SET pulses reach its input pins from different paths, as shown in the figure below.</p> <p> </p> Gate C8 is a reconvergence point, where two SET pulses reach its input pins, due to the divergence of the original SET pulse at the fan-out of gate C2 <p>To propagate the SETs to the output of the reconvergence point the following steps take place:</p> <ol> <li>Each SET pulse is propagated separately through the gates, producing a temporal output SET pulse. The produced SET pulse can be either positive or negative, based on the gate unateness and the direction of the input SET pulse.</li> <li>Examine all the positive temporal SET pulses at the output of the gate, if any, and fuse them as a single positive output SET pulse. The produced positive output SET pulse is constructed as the minimum among the rise temporal SET edges (earliest rise edge) and the maximum of the fall temporal SET edges (latest fall edge).</li> <li>Similarly, examine all the negative temporal SET pulses at the output of the gate, if any, and fuse them as a single negative output SET pulse. The produce negative output SET pulse is constructed as the minimum among the fall temporal SET edges (earliest fall edge) and the maximum of the rise temporal SET edges (latest rise edge).</li> </ol> <p>The following table summarises the output SET pulse cases based on gate unateness and the input SET pulse direction.</p> Reconvergence Output SET Pulse Cases for \"Vanilla\" STA-mode Positive Unate Same Pulse Directions 1 Output SET Pulse Produced Same direction with the input SET pulses Opposite Pulse Directions 2 Output SET Pulses Produced <p><li>Positive input SET \u2192 Positive output SET</li><li>Negative input SET \u2192 Negative output SET</li></p> Negative Unate Same Pulse Directions 1 Output SET Pulse Produced Opposite direction with the input SET pulses Opposite Pulse Directions 2 Output SET Pulses Produced <p><li>Positive input SET \u2192 Negative output SET</li><li>Negative input SET \u2192 Positive output SET</li></p> Binate Same Pulse Directions 2 Output SET Pulses Produced Positive &amp; Negative Opposite Pulse Directions 2 Output SET Pulses Produced Positive &amp; Negative"},{"location":"set_analysis_flow.html#detailed-timestamp-based-sta-mode","title":"Detailed TimeStamp-based STA-mode","text":"<p>The \"Vanilla\" STA-mode even though it is quite fast, the produced SET pulses are not as accurate as those produced by SPICE simulation, especially for reconvergence points. Thus, a more accurate model is required, which is the \"Detailed TimeStamp-based STA-mode\". In this mode, Boolean evaluation at the gate level is performed, taking into account the arrival time of the SET pulses as well as the Boolean function of the examining gate. It is important to note that this mode doesn't perform input vectors justification.</p> Input SET Cases &amp; Possible Output SET Pulse Cases for Detailed TimeStamp-based STA-mode Input SET Cases Possible Output SET Pulse Cases Logically Masked Intersection of Input SET Pulses Union of Input SET Pulses One Input Pulse Propagates / Other One Masked <p>The main difference of this mode compared to the \"Vanilla\" STA-mode lies in the handling of the reconvergence. As mentioned, \"Vanilla\" STA-mode considers each arriving SET pulse separately and performs MAX analysis among all possible temporal output pulses, propagating a single pessimistic output SET pulse. In contrast, in the Detailed TimeStamp-based STA-mode, Boolean evaluation is performed considering the arrival times of the input SET pulses propagating a more realistic SET pulse, compared to \"Vanilla\". In any other case, i.e. no reconvergence, both Detailed and \"Vanilla: mode operate in the same way. A more thorough illustration for Detailed mode is presented in the above table; Each combination of input pulses, presented in the left column, produce an output SET pulse which shape is based on the Boolean function of the examining gate and can be one of those presented on the right side.</p>"},{"location":"set_analysis_flow.html#bounded-timestamp-based-sta-mode","title":"Bounded TimeStamp-based STA-mode","text":"SET output pulse produced by the bounding technique <p>However, the Detailed TimeStamp-based interval analysis, as shown in the above table, can produce a \"train\" of multiple pulses which will be propagated to the forward logic cone. Such a pulse \"train\" can reach another reconvergence point and produce even more pulses, increasing that way the number of timestamp and, thus, the overall runtime of the SET propagation. Therefore, the Bounded TimeStamp-based STA-mode is introduced as a means to speed up the TimeStamp-based interval analysis while achieving at the same time a better accuracy compared to the \"Vanilla\" STA-mode. In the Bounded STA-mode, the timestamp analysis of the above table is performed, but the possible output SET pulse(s) that the Detailed mode would produce are now an intermediate result. The output SET pulse is a single pulse (a single pair of rise and fall edges) constructed by the earliest and latest edge of the individual smaller pulse of the \"train\", as shown in the next figure. Thus, a pulse \"train\" is never propagated to the forward logic cone, reducing the execution time of the TimeStamp-based interval analysis compared to the Detailed TimeStamp-based STA-mode.</p>"},{"location":"set_analysis_flow.html#masking-mechanisms","title":"Masking Mechanisms","text":"<p>The propagation of a SET pulse may stop due to the existence of the three masking mechanisms: (i) Logical, (ii) Electrical, and (iii) Timing-Window Masking.</p>"},{"location":"set_analysis_flow.html#logical-masking","title":"Logical Masking","text":"Logical Masking <p>Logical Masking occurs when a SET pulse arrives at an input of a gate and its propagation stops because one of the side input is at a controlling logic value, or the values of the side inputs doe not allow the SET arriving at the input of the gate to propagate to the output. That way, the SET pulse is filtered and the output of the gate will remain at its nominal value.</p> <p>For logical masking to be supported, the current state of the circuit must be specified. In Vector-based SET analysis, this can be done by creating a case analysis giving values to gatepins, while in Probabilistic SET analysis this can be done by annotating the gatepins with their static probabilities, either by loading a SAIF file or using the 0-Algorithm. More information about the circuit state definition refer to the section Circuit State Definition. Moreover, a SET probability lower threshold exists that determines whether the propagated pulse to the output is logically masked.</p>"},{"location":"set_analysis_flow.html#electrical-masking","title":"Electrical Masking","text":"<p>Electrical masking occurs due to the parasitic capacitance and resistance of the subsequent gate in the sensitised path, as well as the wire load effect, attenuating the generated SET pulse. Attenuation of a SET pulse results in a non full-swing signal, i.e. 0 \u2192 Vdd / Vdd \u2192 0, something that is not supported natively by the STA engine.</p> <p> </p> Electrical Masking <p>To detect if a SET pulse becomes electrically masked as it is propagated through the forward logic cone, the pulse width (<code>PW</code>) is checked. The latter is computed as shown in the figure below, based on the rise and fall arrival times, which are related to the Vth amplitude of each edge.</p> Detection by STA engine if a SET pulse is electrically masked Not Electrically Masked SET Pulse Electrically Masked SET Pulse <p>In case the SET pulse width is positive (left figure above), then the SET pulse is not electrically masked and the SET pulse propagation continues. Otherwise, the SET pulse is electrically masked, as shown in the right figure above, and the propagation is terminated.</p>"},{"location":"set_analysis_flow.html#timing-window-masking","title":"Timing-Window Masking","text":"Timing-Window Masking <p>Nonetheless, logical and electrical masking may not be able to filter the SET pulse, and the latter may be able to reach a sequential element. Timing-window masking occurs when a SET pulse reaches the input of a sequential element but outside the [<code>SETUP</code>, <code>HOLD</code>] window during which the sequential element captures the input data, and thus this SET is ignored.</p> <p>Timing-Window masking occurs due to the temporal randomness of the particle strike time and the realisation that the pulse arrival time at the latch has to be within the latching window for the error to occur. In section Probabilistic Timing-Window Masking more details on the supported model of the timing-window masking are provided.</p>"},{"location":"set_analysis_flow.html#set-probabilities-computation","title":"SET Probabilities Computation","text":"<p>As mentioned in section Logical Masking, the SET propagation continues until the side input values of the reaching gate filter out the incoming fault. This requires the nominal state of the circuit, which is specified directly in the Vector-based SET Analysis. However, in Probabilistic SET Analysis the static probabilities are extracted after teh circuit simulation for the target application. These probabilities provide a general understanding onf the circuit's state, indicating the probability of each gate being at logic-1 or logic-0. Thus, as each gatepin in the circuit is associated with a probability, the SET generation and propagation can also be linked with a probability (\\(P_{SET}\\)).</p>"},{"location":"set_analysis_flow.html#initial-set-probability","title":"Initial SET Probability","text":"<p>Generating a SET pulse at the output of the target gate requires the latter to be in the appropriate state. Thus, generating a positive SET requires the target gate's output to be at logic-0; otherwise, the SET would not be observable. Similarly, this principle applies to the generation of negative SET pulses. That way, the initial SET probability is equal to its static probability \\(P_0(G_i)\\) for a positive SET generation at the gate \\(G_i\\), and its static probability \\(P_1(G_i)\\) for a negative SET generation at the gate \\(G_i\\), as shown in the following equation:</p> \\[ P^{init}_{SET}(G_i) =  \\begin{cases} \\text{P}_0\\text{(G}_\\text{i}\\text{),} &amp;\\quad\\text{positive SET pulse generation} \\\\ \\text{P}_1\\text{(G}_\\text{i}\\text{),} &amp;\\quad\\text{negative SET pulse generation} \\\\ \\end{cases} \\]"},{"location":"set_analysis_flow.html#non-reconvergence-case","title":"Non-Reconvergence Case","text":"<p>After the SET generation at the output of the gate, it is propagated to the forward logic cone. As the SET pulse traverses through subsequent gates, its SET probability must be updated to reflect the probability of the SET pulse occurring at the gate's output. When a single (non-reconvergence) SET arrives at the input of a gate, then the SET propagates to the output of the gate only when the side inputs values do not filter the fault. Thus, the SET probability at the output of the reached gate \\(G_i\\) can be computed as:</p> \\[ P_{SET}(G_i/out) = P_{SET}(G_i/\\alpha) \\times \\sum_{m \\in M(\\alpha)} P_{side}(m) \\] <p>, with \\(G_i/\\alpha\\) being the input pin of gate \\(G_i\\), where the SET pulse arrives with probability \\(P_{SET}(G_i/\\alpha)\\). As for the sum \\(\\sum_{m \\in M(\\alpha)} P_{side}(m)\\), \\(M(\\alpha)\\) is the set of the side inputs values combinations, in the canonical form of minterms, that allow the SET to propagate to \\(G_i\\)'s output, and \\(P_{side}(m)\\) is the probability for each combination.  An example with a positive SET pulse reaching an AND gate is shown in the figure below.</p> <p> </p> Output SET Probability for a positive SET pulse reaching an AND gate"},{"location":"set_analysis_flow.html#reconvergence-case","title":"Reconvergence Case","text":"<p>In the case of reconvergence, the computation of the SET probability at the output of the gate depends on the STA-mode used for the SET propagation (similar to the shape of the output SET pulse).</p>"},{"location":"set_analysis_flow.html#set-probability-computation-in-vanilla-sta-mode","title":"SET Probability Computation in \"Vanilla\" STA-mode","text":"<p>As mentioned in section \"Vanilla\" STA-mode, \"Vanilla\" STA-mode is the fastest but also the most pessimistic mode among the other STA-modes. Thus, since the produced output SET pulse is the worst case pulse, its SET probability must also be the worst case.</p> <p>In general, in this mode, two output SET pulses can be produced, i.e. a positive one and a negative one. Each input SET pulse is considered separately, producing one or two pulses at the output based on the gate unateness, as shown in this table.</p> <p>As for the shape of a positive SET pulse, MAX analysis is performed among the intermediate positive SET pulses, and it is constructed by the earliest rise and latest fall edge (as described in section \"Vanilla\" STA-mode). As for the corresponding SET probability, once more, MAX analysis is performed among the probabilities of the input SET pulses producing an intermediate positive SET pulse. Based on this SET pulse, the side input values propagating this SET pulse to the output are extracted and the final output SET probability for the positive SET pulse is:</p> \\[ P^{POS}_{SET}(out) = P_{SET}(I) \\times \\sum_{m \\in M(I)} P_{side}(m) \\] <p>where \\(P_{SET}(I) = \\max \\{P^{pos}_{SET}(i_1), ..., P^{pos}_{SET}(i_n)\\}\\) is the probability of SET pulse \\(I\\), which is the one with the maximum probability among those producing a positive SET pulse at the output of the gate. Similarly to the non-reconvergence case, the $\\sum_{m \\in M(I)} P_{side}(m) $ is the accumulated probability of all side input values combinations propagating to the output from the input SET pulse \\(I\\). Similarly, based on the same principles, the probability of a negative output SET pulse can be computed.</p> <p> </p> Reconvergence of two SET pulses with different directions at a XOR gate <p>An example is provided in the figure to clarify the aforementioned computation method, demonstrating the reconvergence of two SET pulses with different directions at a XOR gate. The SET probabilities for the pulses are \\(P_{SET}(\\alpha) = 0.5\\) and \\(P_{SET}(b) = 0.75\\), respectively. Each input SET pulse is handled separately.</p> <ul> <li>Positive SET pulse at input pin \\(\\alpha\\): Since the SET reaches a binate gate, it produces a positive intermediate SET pulse through the positive unate arc (1) and a negative one through the negative unate arc (2).</li> <li>Negative SET pulse at input pin \\(b\\): Since the SET reaches a binate gate, it produces a positive intermediate SET pulse through the negative unate arc (3) and a negative one through the positive unate arc (4).</li> </ul> <p>Finally, at the output of the XOR gate, two SET pulses will be produced:</p> <ul> <li>a positive one, after performing MAX analysis among intermediate pulses (1) and (3), with SET probability \\(P_{SET}(out|pos) = \\max \\{P_{SET}(\\alpha), P_{SET}(b)\\} = 0.75\\), and</li> <li>a negative one, after performing MAX analysis among intermediate pulses (2) and (4), with SET probability \\(P_{SET}(out|neg) = \\max \\{P_{SET}(\\alpha), P_{SET}(b)\\} = 0.75\\)</li> </ul>"},{"location":"set_analysis_flow.html#set-probability-computation-in-detailed-timestamp-based-sta-mode","title":"SET Probability Computation in Detailed TimeStamp-based STA-mode","text":"<p>In contrast to \"Vanilla\" STA-mode, where MAX analysis is performed for the computation of the output SET probability, in the Detailed TimeStamp-based mode the output SET pulse probability depends on the output pulse case (presented in this table) based on which the output SET is constructed. The following table presents the equations for the computation of the output SET pulse probability for each output pulse case.</p> <p>Detailed TimeStamp-based STA-mode Output SET Probability Computation</p> Output SET Pulse Case Example Output SET Probability Logically Masked $$P_{SET}(out)=0$$ Intersection of Input SET Pulses $$P_{SET}(out)=P_{SET}(\\alpha) \\times P_{SET}(\\beta)$$ Union of Input SET Pulses Non-Overlapping $$P_{SET}(out)=max\\{P_{SET}(\\alpha),P_{SET}(\\beta)\\}$$ Overlapping One Input SET Pulse Propagates / Other One Gets Masked Non-Overlapping $$P_{SET}(out)=P_{SET}(pulse_{propagated})$$ Overlapping <p>The above equations compute the output SET probability considering only the input SET pulses and not the side inputs values. Thus, to compute the final output SET probability, the latter is multiplied with the probability of side input combinations allowing the produced SET pulse to appear at the output of the gate (similarly with the equation in section Non-Reconvergence Case).</p>"},{"location":"set_analysis_flow.html#set-probability-computation-in-bounded-timestamp-based-sta-mode","title":"SET Probability Computation in Bounded TimeStamp-based STA-mode","text":"<p>As for the Bounded TimeStamp-based STA-mode, the only difference with the Detailed one, is that instead of producing pulse trains at the output of the gate, it creates a unified pulse constructed by the earliest and latest edge of the train, as shown in this figure. As for the computation probability of the output SET pulse, the equations of the Detailed mode are still valid for the Bounded mode. </p>"},{"location":"set_analysis_flow.html#probabilistic-timing-window-masking","title":"Probabilistic Timing-Window Masking","text":"<p>Concluding the phase of the SET propagation the SET pulse might reach some sequential elements of the circuit. To compensate with the probabilistic nature of UPSET's SET propagation, the latching probability of the SET pulse \\(P_{Latched SET}(E_i)\\) arriving at an endpoint pin \\(E_i\\) (PO or sequential output) is defined as:</p> \\[ P_{Latched SET}(E_{i}) = P_{SET}(E_{i}) \\times \\frac{PW - W_{Latching}}{P_{clock}} \\] <p>, with \\(P_{SET}(E_{i})\\) the SET pulse probability at \\(E_{i}\\), \\(PW\\) pulse width time duration of the examined SET, while \\(W_{Latching}\\) is the latching timing window at \\(E_{i}\\) and \\(P_{clock}\\) is the period of the related clock.</p>"},{"location":"set_optimisation_techniques.html","title":"SET-driven Optimisation Techniques","text":"<p>After a complete SET analysis, several techniques can be used to optimise the circuit sensisitivity to the SETs. A brief description of each technique is presented in the following sections. </p>"},{"location":"set_optimisation_techniques.html#pin-assignment-rewiring","title":"Pin Assignment / Rewiring","text":"<p>Pin assingment / rewiring is a technique used in logic synthesis to improve the circuit power and performance by taking advantage of the functional equivalence of input pins of logic gates. For example, for a NAND gate, as shown in the next figure, the output evaluates to logic-1 whenever one of its inputs is in logic-0, regardless of the input pin (A or B). This symmetric behaviour is observed in all 2-input basic standard cell gates. As each input pin of a logic gate presents different electrical characteristics depending on the transistor network, they will have different effects on the SET propagation through this pin. Candidate gates for pin assignment are those gates that present an imbalance in broadening characteristics between their timing arcs as well as an imbalance in the PWs of the arriving SET pulses at their input pins.</p> <p> </p> Pin Assignment / Rewiring for a logic gate <p>To perform rewiring for a target gate in UPSET, the following TCL command can be used:</p> <pre><code>%&gt; eco_swap_component_pins &lt;gatepin name 1&gt; &lt;gatepin name 2&gt;\n</code></pre> <p>where the two gatepins to be swapped are specified by their names. The gatepin name has the format component_name/pin_name.</p>"},{"location":"set_optimisation_techniques.html#gate-resizing","title":"Gate Resizing","text":"<p>The most popular gate-level SET mitigation technique is symmetric gate resizing, i.e. replacement of a smaller gate by a larger one, as shown in the next figure. Sizing up a gate increases the effective capacitance of the device thereby making it less likely that the injected SET transient current to cuase a voltage glitch of sufficient magnitude. As a result, the gate will have a lower probability of generating a SET due to a direct particle strike.</p> Effect of Gate Resizing on SET Generation Generation of a SET pulse at the output of the gate before resizing. Generation of a SET pulse at the output of the gate after resizing. The amplitude of the generated SET pulse is sufficiently reduced <p>However, upsizing a gate will result in higher drive strength which allows for better propagation of input SET transient at the gate. This behaviour is summarised the following figure. Thus, applying gate resising must be carefully applied, as it may degrage the SET hardness of the circuit.</p> <p> </p> Effect of Gate Resizing on SET Generation and Propagation <p>To perform gate resizing for a target gate in UPSET, the user can either upsize or downsize a gate to the immediate next larger or smaller gate, respectively. To upsize or downsize a gate, the following TCL command can be used:</p> <pre><code>%&gt; eco_upsize_component &lt;component name&gt; ?-overlapsmethod &lt;1 | 2 | 3&gt;?\nor \n%&gt; eco_downsize_component &lt;component name&gt; ?-overlapsmethod &lt;1 | 2 | 3&gt;?\n</code></pre> <p>, where the target component to be upsized or downsized is specified. The user can also specify the overlap handling method, which can be one of the following:</p> Overlap Handling Method Description 1 (default) Remove from rows and mark as illegal only the overlapping components 2 Remove from rows and mark as illegal both the resized and the overlapping components 3 Remove from rows and mark as illegal only the resized component <p>The overlap handling method is optional and if not specified, the default overlap handling method is used.</p>"},{"location":"set_optimisation_techniques.html#insertion-of-charge-sharing-logic","title":"Insertion of Charge-Sharing Logic","text":"<p>Since the SET is a temporal charge-induced event, increasing the output capacitance of the logic gate can reduce the susceptibility of the logic gate to SETs. One way of achieving that is by connecting redundant logic to its output, as shown in the next figure. Insertion of redundant logic increases the gate's output capacitance and, thus, facilitates the dissipation og particle-induced charge, and enhances the SET electrical filtering. The redundant logic can be implemented by a few inverters, buffers or other gates whose inputs are connected to the target node, while their outputs are left to float or connected to the ground GND. The insertion of charge-sharing logic is complementary to gate resizing with the difference that increases only the capacitance of the output node and, thus, affects the subsequent logic cone without affecting the predecessor interconnects, as the input pins loads remain the same. Candidate gates for inserting charge-sharing logic can ve those that present a high broadening factor (since the broadening occurs due to load imbalance between subsequent gates) as well as those that have large maximum PW at their outputs.</p> <p> </p> Insertion of charge-sharing logic composited by INVs <p>To insert charge-sharing logic to a target gate in UPSET, the following TCL command can be used:</p> <pre><code>%&gt; eco_charge_sharing &lt;target gatepin&gt; -cell &lt;delay cell&gt; -num &lt;number of delay cells&gt; ?-placementmethod &lt;0 (Default Placement) | 1 (Place in the centre-of-mass) | 2 (Place in the centre-of-mass and remove overlapping components)&gt;?\n</code></pre> <p>where the gatepin of the target gate to insert charge-sharing logic is specified and also the number and type of delay cells (libcell name as specified in the library) to be used. Finally, optionally the placement method can be specified. The placement method can be one of the following:</p> Placement Method Description 0  (default) Place the new components at (0, 0) 1 Place the new components at the centre of mass 2 Place the new components at the centre of mass and remove overlapping components <p>The placement method is optional and if not specified, the default placement method is used.</p>"},{"location":"set_optimisation_techniques.html#fan-out-decomposition","title":"Fan-out Decomposition","text":"<p>An alternative approach to the insertion of charge-sharing logic, which aims to increase the load of a target gate in order to achieve SET sensitivity reduction, is to reduce the output load of the gate by performing fan-out decomposition in order to balance it across the levels. One way to achieve this is by performing gate duplication. As shown in the following figure, the target gate is duplicated with the inputs of the two clones eing tied together, while the fan-out of the target gate is split into the two clones. After gate cloning, each clone has a lower output load compared to the initial load of the target gate making it more susceptible to direct particle strikes. However, each SET pulse generated at each one of the replicas by direct partice strike affects fewer endpoints. Moreover, by reducing the output load for the targe gate with fan-out decomposition, the output load of the predecessors gets increased since the clone is added to their fan-outs, which might result in a load imbalance between predecessors and the clones increasing the probability of observing broadening effects.</p> <p> </p> Fan-out Decomposition by performing gate cloning <p>To perform fan-out  decomposition in UPSET, the following TCL command can be used:</p> <pre><code>%&gt; eco_fanout_decomposition &lt;target component&gt; ?-placementmethod &lt;0 (Default Placement) | 1 (Place in the centre-of-mass) | 2 (Place in the centre-of-mass and remove overlapping components)&gt;?\n</code></pre> <p>where the component of which the fan-out will be decomposed is specified. Finally, optionally the placement method can be specified. The placement method can be one of the following:</p> Placement Method Description 0  (default) Place the new components at (0, 0) 1 Place the new components at the centre of mass 2 Place the new components at the centre of mass and remove overlapping components <p>The placement method is optional and if not specified, the default placement method is used.</p>"},{"location":"set_optimisation_techniques.html#triple-modular-redundancy-tmr","title":"Triple Modular Redundancy (TMR)","text":"<p>Another technique to reduce the SET sensitivity of critical nodes is by introducing redundancy at teh gate level. One of the most commong methods is the Triple Modular Redundancy (TMR), where the target gate is triplicated with the inputs of each replica being tied together and their outputs connected to a majority voter. Also, a delay is added to 2 out of the 3 replicas (\\(\\delta\\) and \\(2\\delta\\)), as shown in the figure below, in order to filter the incoming SET pulses and thus the TMR to be able to filter the fault. </p> <p> </p> Triple Modular Redundancy <p>Warning</p> <p>Current version of UPSET does not add the delays to the 2 out of the 3 replicas of the TMR, which protects the TMR from propagated SETs. This will be supported in the next version of UPSET.</p> <p>However, the TMR introduces significant power, performance and area overhead and also inserts extra gates to the circuit, which are potential additional target gates for SET generation, as shown in the following figure. So, the TMR would be the last mitigation technique to be applied if the rest are not able to achieve significant SET sensitivity reduction.</p> <p> </p> The majority voter is a new target gate for SET generation <p>To apply TMR to a target gate, the following TCL command is used:</p> <pre><code>%&gt; eco_tmr_component &lt;compoent_name&gt; ?-placementmethod &lt;0 (Default Placement) | 1 (Place in the centre-of-mass) | 2 (Place in the centre-of-mass and remove overlapping components)&gt;?\n</code></pre> <p>, where the user must specify the name of the target gate to be TMR'ed and the placement method to be used. The placement method can be one of the following:</p> Placement Method Description 0  (default) Place the new components at (0, 0) 1 Place the new components at the centre of mass 2 Place the new components at the centre of mass and remove overlapping components <p>The placement method is optional and if not specified, the default placement method is used.</p> <p>As for the majority voter, the following architecture is used by UPSET:</p> <p> </p> Majority Voter composed by 4 NAND gates"},{"location":"set_optimisation_techniques.html#insertion-of-set-filter","title":"Insertion of SET Filter","text":"<p>The insertion of SET filters in the circuit is another technique that aims to reduce the maximum pulse width that is observed at a target node of the circuit. The structure of a SET fulter is shown in the following figure, where the output of the target gate is connected to a delay line and a guard gate. The SET filter is able to filter any SET pulse with PW less than or equal to the added \\(\\Delta\\) delay, due to the reconvergence in the guard gate. Moreover, for SETs with PWs greater than the inserted delay, even though it is not able to filter it completely, it reduces its PW by an amount equal to \\(\\Delta\\). However, since the SET filtering adds extra delay in the second path, this approach increases the delay of the related path. To efficiently use the SET filter insertion, the target gates where the SET will be applied as well as the amount of delay to be inserted must be considered carefully. Finally, the SET filter inserts extra gate to the circuit and especially the guard gate which is a potential additional target gate for SET generation.</p> <p> </p> Insertion of SET Filter <p>To insert a SET filter at the output of a target gate in UPSET, the following TCL commandd is used:</p> <pre><code>%&gt; eco_insert_filter &lt;target gatepin&gt; -cell &lt;delay cell&gt; -num &lt;number of delay cells&gt; -AND &lt;AND cell&gt; ?-placementmethod &lt;0 (Default Placement) | 1 (Place in the centre-of-mass) | 2 (Place in the centre-of-mass and remove overlapping components)&gt;?\n</code></pre> <p>where the gatepin of the target gate to insert a SET filter is specified and also the delay cell (libcell name as specified in the library) as well as the AND gate for the voting to be used for the SET filter. Finally, optionally the placement method can be specified. The placement method can be one of the following:</p> Placement Method Description 0  (default) Place the new components at (0, 0) 1 Place the new components at the centre of mass 2 Place the new components at the centre of mass and remove overlapping components <p>The placement method is optional and if not specified, the default placement method is used.</p> <p>Bug</p> <p>The current version of SET filter insertion is supporting the insertion of an AND gate for the voting, instead of a guard gate. However, this is not correct, since the AND gate will result in broadening negative (1-&gt;0-&gt;1) SET pulses instead of attenuating them. Thus, the SET filter insertion should be updated to support the insertion of a guard gate in the next release.</p>"},{"location":"set_optimisation_techniques.html#insertion-of-cascaded-inverters","title":"Insertion of Cascaded Inverters","text":"<p>Alternative to the insertion of SET filters, SET filtering can be achieved by inserting cascaded inverters in a logic path, where the second inverter is significantly larger compared to the first one,  as shown in the figure below. Reducing the difference in the drive strengths between the cascaded inverters weakens the filtering capability. However, on the other hand, increasing the difference in the drive strenghts between them increase the overhead introduced both in power and delay. Instead or two cascaded inverters, a standard buffer from the library could bbe used, however, they often are composed of two inverters where the one inverter is x2-x3 larger than the other one and, thus, they are not sufficient for SET filtering. </p> <p> </p> Insertion of Cascaded Inverters for SET filtering <p>To add cascaded inverters to the output of a target gate in UPSET, the following TCL command can be used:</p> <pre><code>%&gt; eco_insert_cascaded_inverter &lt;target gatepin&gt; -cells &lt;cell 1&gt; &lt;cell 2&gt; ?-placementmethod &lt;0 (Default Placement) | 1 (Place in the centre-of-mass) | 2 (Place in the centre-of-mass and remove overlapping components)&gt;?\n</code></pre> <p>where the gatepin of the target gate to insert cascaded inverters is specified and also the two INV cells (libcell name as specified in the library) to be used for the cascaded inverters. Finally, optionally the placement method can be specified. The placement method can be one of the following:</p> Placement Method Description 0  (default) Place the new components at (0, 0) 1 Place the new components at the centre of mass 2 Place the new components at the centre of mass and remove overlapping components <p>The placement method is optional and if not specified, the default placement method is used.</p>"},{"location":"set_optimisation_techniques.html#set-analysis-optimisation-flow","title":"SET Analysis &amp; Optimisation Flow","text":"<p>The SET analysis and optimisation flow is presented in the following figure.</p> <p> </p> SET Analysis &amp; Optimisation Flow <p>It is important to note that each SET mitigation technique might result in an illegal placement state. To resolve this, the user can perform legalisation wheneever he wants by using the TCL command:</p> <pre><code>%&gt; legalise_components -order &lt;0 (all) | 1 (increasing) | 2 (decreasing) | 3 (centre-outwards)&gt; -blockagesmethod &lt;0 (Subrow Assignment - SRA) | 1 (Subrow Reassignment - SRR)&gt; ?-timingdriven &lt;longest | shortest&gt;? ?-htmlreport &lt;filename&gt;?\n</code></pre> <p>where the user can specify the order of the legalisation, the blockage method, the timing driven analysis and the name of the HTML report file to be generated. Check the TCL command legalise_components for more details.</p> <p>Warning</p> <p>Before each SET analysis is performed, the components must be legalised.</p> <p>Finally, performing SET mitigation techniques affect the circuit timing info, which must be updated. To update the timing info, the user can use the TCL command:</p> <pre><code>%&gt; report_timing ?-longest|-shortest? ?-corner &lt;corner_index&gt;? ?-backannotate?\n</code></pre> <p>Check the TCL command report_timing for more details, as well as the Static Timing Analysis (STA) section.</p> <p>Warning</p> <p>Before performing SET analysis, the circuit timing info must be updated.</p>"},{"location":"set_sensitivity_metrics.html","title":"SET Sensitivity Metrics","text":"<p>After the SET Analysis is completed a list of sensitivity metrics both for the whole circuit as well as each circuit gatepin are expected.</p>"},{"location":"set_sensitivity_metrics.html#accumulated-sets-aset","title":"Accumulated SETs (ASET)","text":"<p>For each endpoint of the circuit, i.e. Primary Output (PO) and Flip-Flop Input, the total number of SETs reached is computed. However, since the arrival of a SET is associated with its SET probability, then the accumulated number of SETs for an endpoint \\(e\\) and a specified SET scenario \\(s\\), \\(ASET(e,s)\\) is computed as follows:</p> \\[ ASET(e, s) = \\sum_{p}^{\\#pulses}P_{SET}(e, s) \\] <p>In addition, the accumulated number of SETs for an endpoint \\(e\\), considering all the SET scenarios that reached this endpoint, is computed as:</p> \\[ ASET(e) = \\sum_{s}^{\\#scenarios}ASET(e,s) \\] <p>Finally, the total number of accumulated SETs reaching all the endpoints of the circuit is computed as:</p> \\[ ASET_{total} = \\sum_{e}^{\\#endpoints}ASET(e) \\] <p>and the average one as well:</p> \\[ ASET_{avg} = \\frac{\\sum_{e}^{\\#endpoints}ASET(e)}{\\#endpoints} \\]"},{"location":"set_sensitivity_metrics.html#latched-accumulated-sets-laset","title":"Latched Accumulated SETs (LASET)","text":"<p>Considering the effect of timing-window masking, similarly to ASET, the Latched Accumulated SETs (LASET) for an endpoint \\(e\\) and a specified SET scenario \\(s\\), \\(LASET(e,s)\\) is computed as follows:</p> \\[     LASET(e, s) = \\sum_{p}^{\\#pulses}P_{SET}(e, s)\\times \\frac{PW - W_{Latching}}{P_{clock}} \\] <p>Similarly to ASET, the LASET for a specified endpoint \\(e\\) considering all the SET scenarios that reached this endpoint is computed as:</p> \\[     LASET(e) = \\sum_{s}^{\\#scenarios}LASET(e,s) \\] <p>Finally, the total number of accumulated SETs reaching all the endpoints of the circuit is computed as:</p> \\[     LASET_{total} = \\sum_{e}^{\\#endpoints}LASET(e) \\] <p>and the average one as well:</p> \\[     LASET_{avg} = \\frac{\\sum_{e}^{\\#endpoints}LASET(e)}{\\#endpoints} \\]"},{"location":"set_sensitivity_metrics.html#accumulated-pulse-width-apw","title":"Accumulated Pulse Width (APW)","text":"<p>In addition to the Accumulated (Latched) SETs which is the sum of probabilities for all the SETs reaching a circuit endpoint, the accumulated PW per endpoint is also calculated. The Accumulated Pulse Width (APW) for an endpoint \\(e\\) and a specified SET scenario \\(s\\), \\(APW(e,s)\\) is computed as follows:</p> \\[     APW(e,s) = \\sum_{p}^{\\#pulses}PW(e,s) \\] <p>In addition, the accumulated PW of the SETs reaching an endpoint \\(e\\), considering all the SET scenarios that reached the endpoint, is computed as:</p> \\[     APW(e) = \\sum_{s}^{\\#scenarios}APW(e,s) \\] <p>Finally, the total accumulated PW of SETs reaching all the circuit endpoints is computed as follows:</p> \\[     APW_{total} = \\sum_{e}^{\\#endpoints}APW(e) \\] <p>and the average one as well:</p> \\[     APW_{avg} = \\frac{\\sum_{e}^{\\#endpoints}APW(e)}{\\#endpoint} \\]"},{"location":"set_sensitivity_metrics.html#component-sensitivity-metrics","title":"Component Sensitivity Metrics","text":"<p>In addition to the ASET for endpoints and the whole circuit, a list of sensitivity metrics for each circuit gatepin. These metrics can be used by the designer to target gates during SET-driven optimisations</p>"},{"location":"set_sensitivity_metrics.html#impact-ratio-ir","title":"Impact Ratio (\\(IR\\))","text":"<p>The Impact Ratio (\\(IR\\)) for an output gatepin \\(g_i\\) is defined as the ratio of the number of affected endpoints (POs and FF inputs) by a SET pulse generated at \\(g_i\\) over the number of reachable endpoints.</p> <p>Thus, for an output gatepin \\(g_i\\) and a defined SET scenario targeting \\(g_i\\), the Impact Ratio is computed as follows:</p> \\[     IR(s, g_i) = \\frac{affected\\_endpoints(s, g_i)}{reachable\\_endpoints(g_i)} \\] <p>For the gatepin \\(g_i\\), also the worst \\(IR\\) among all the SET scenarios targeting \\(g_i\\) is computed as:</p> \\[     worstIR(g_i) = \\max_{s}^{\\#scenarios}\\{IR(s, g_i)\\} \\]"},{"location":"set_sensitivity_metrics.html#maximum-pulse-width-mpw","title":"Maximum Pulse Width (\\(MPW\\))","text":"<p>The Maximum Pulse Width (\\(MPW\\)) for a gatepin \\(g_i\\) is the maximum pulse width over all the SET pulses reaching this gatepin.</p> <p>For a gatepin \\(g_i\\) and a specified SET scenario \\(s\\), the Maximum Pulse Width is computed as follows:</p> \\[     MPW(s, g_i) = \\max_{p}^{arriving_pulses}\\{PW(p, s, g_i)\\} \\] <p>Also the worst \\(MPW\\) among all the SET scenarios that reach the gatepin \\(g_i\\) is computed:</p> \\[     worstMPW(g_i) = \\max_{s}^{\\#scenarios}\\{MPW(s, g_i)\\} \\]"},{"location":"set_sensitivity_metrics.html#broadening-factor-bf","title":"Broadening Factor (\\(BF\\))","text":"<p>A SET pulse traversing through a gate can be either broadened or attenuated based on the effect of the gate. Thus, for each output gatepin of the circuit the Broadening Factor (\\(BF\\)) is computed as the ratio of the maximum pulse width among the SET pulses appeared at the output of the gate over the maximum pulse width among the input SET pulses.</p> <p>Thus, for an output gatepin \\(g_i\\) and a defined SET scenario \\(s\\), the broadening factor can be computed as follows:</p> \\[     BF(s, g_i) = \\frac{\\max_{p}^{output\\_pulses}\\{PW(p, s, g_i)\\}}{\\max_{p}^{input\\_pulses}\\{PW(p, s, g_i)\\}} \\] <p>Also the worst \\(BF\\) among all the SET scenarios is computed:</p> \\[     worstBF(g_i) = \\max_{s}^{\\#scenarios}\\{BF(s, g_i)\\} \\] <p>If \\(BF &gt; 1\\), then the gate results in SET pulse broadening, and, thus, it is more critical for the total circuit sensitivity. Otherwise, if \\(BF &lt; 1\\), then the SET pulse traversing through this gate is attenuated, and the gate reduces the impact of SET.</p>"},{"location":"set_sensitivity_metrics.html#set-generation-probability-p_gen","title":"SET Generation Probability (\\(P_{gen}\\))","text":"<p>Among the above SET sensitivity metrics related to the SET propagation, the gate sensitivity related to its resistance to generate a SET pulse must be defined. Thus for each output gatepin of the circuit, the SET Generation Probability is defined, both for positive (\\(P_{gen}^{POS}\\)) and negative SET pulse generation (\\(P_{gen}^{NEG}\\)). The reason behind separating positive and negative SET pulse generation probability is that a gate might be more resistant to generating SET pulses in one direction over the other.</p> <p>Thus, for an output gatepin \\(g_i\\) of the circuit, the positive and negative SET pulse generation probability can be defined as follows:</p> \\[     P_{gen}^{POS}(g_i) = P_0^{static}(g_i) \\times \\frac{\\# \\text{Successful SET Generations}}{\\# \\text{SET Generations Attempts}} \\] \\[     P_{gen}^{NEG}(g_i) = P_1^{static}(g_i) \\times \\frac{\\# \\text{Successful SET Generations}}{\\# \\text{SET Generations Attempts}} \\]"},{"location":"tool_fundamentals.html","title":"Tool Fundamentals","text":"<p>The user can run UPSET via the command line as follows:</p> <pre><code>%&gt; &lt;path_to_upset&gt;/./pathviz ?-help? ?-no_gui? ?-f &lt;TCL_script&gt;?\n</code></pre> <p>where:</p> <ul> <li><code>&lt;path_to_upset&gt;</code> is the path to the UPSET directory</li> <li><code>?-help?</code> is an optional argument that displays a help message, describing UPSET command line arguments</li> <li><code>?-no_gui?</code> is an optional argument that disables the GUI. To show the GUI or hide it, TCL commands <code>show_gui</code> and <code>hide_gui</code> can be used</li> <li><code>?-f &lt;TCL_script&gt;?</code> is an optional argument that specifies the TCL script to be executed</li> </ul>"},{"location":"tool_fundamentals.html#default-upset-startup-script","title":"Default UPSET Startup Script","text":"<p>A default UPSET Startup Script is executed if  the relevant file exists. The default ASP TCL script should be named as config.asp and exist in the same directory as the UPSET executable.</p>"},{"location":"tool_fundamentals.html#error-reporting-and-bugs","title":"Error Reporting and Bugs","text":"<p>The output of the tool should be saved in a log file for later reference and ease of searching problems and bugs in the log. Log generation is not automatic, and should be performed by the user, by invoking the tool using the <code>tee</code> Unix command, as follows:</p> <pre><code>%&gt; &lt;path_to_upset&gt;/./pathviz | tee &lt;log_file&gt;\n</code></pre> <p>where:</p> <ul> <li><code>&lt;path_to_upset&gt;</code> is the path to the UPSET directory</li> <li><code>&lt;log_file&gt;</code> is the name of the log file to be created</li> </ul> <p>In casem only the output of the specific TCL commands is desired, then the log generation is performed by surroing the TCL commands, for which the output must be saved in the log file, with the following TCL command:</p> <pre><code>%&gt; log_output_to_file &lt;log_file&gt;\n# &lt;TCL commands&gt;\n%&gt; close_log_output_file\n</code></pre> <p>where:</p> <ul> <li><code>&lt;log_file&gt;</code> is the name of the log file to be created</li> </ul>"},{"location":"tool_fundamentals.html#upset-graphical-user-interface-gui","title":"UPSET Graphical User Interface (GUI)","text":"<p>The UPSET User Interface is shown below. It consists of:</p> <ul> <li>a Layout Area, where the design's Floorplan and Standard-Cell Placement is shown</li> <li>a Hierarchy Browser, illustrating the design's hierarchical stricture, and</li> <li>a set of Flow Step buttons, Toolbar Icons and Menus.</li> </ul> <p></p> <p>The Path View and the Path Buttons are not used for the UPSET flow but represent alternative tool functionality. Flow steps buttons correspond the different design contexts, which may be simultaneously loaded. By clicking a Flow Step button, a different design context is loaded, and the Layout Area is updated to show the design context. This feature is not directly relevant to the UPSET flow. Flow steps may be used to load multiple, potentially different designs in memory. The sole restriction is that the design libraries (LEF) are common. The Hierarchy Browser, except for illustrating the design's hierarchy, also allows Verilog module operation to be performed, e.g. obtaining information on a given module through the GUI. All GUI operations are also available through the TCL scripting interface. The File Menu corresponds to importing and exporting data (LEF, LIB, DEF, Verilog, SDF, STA Report), the Edit Menu corresponds to GUI setup, searching for nets or components and various other basic operations, the Tool Modes Menu is used for alternative tool functionality, the Design Menu is used to output various design data, e.g. components, gate pins, modules, etc., whereas the Placement Flow Menu contains all the steps of the ASP flow and is thus the most relevant.</p>"},{"location":"top_level_flows.html","title":"SET Analysis Top-Level Flows","text":"<p>Thus far, each of the SET Analysis (as shown here) has been described in detail separately. This page provides a condensed description to run a complete SET analysis flow.</p>"},{"location":"top_level_flows.html#set-generation-and-propagation-mode-selection","title":"SET Generation and Propagation Mode Selection","text":"<p>The user can select the SET analysis mode and determine the required accuracy via the following key TCL commands:</p> <pre><code># Set the timing model for the ASP tool\n%&gt; set_timing_model &lt;nldm | ccs&gt;\n\n# Set the SET analysis mode\n%&gt; set_SET_analysis_mode &lt;0: Vector-based | 1: Probabilistic&gt;\n\n# Set the SET generation parameters\n%&gt; set_SET_generation_parameters -model &lt;DEXP | BIAS&gt; -biascapacitance &lt;BIAS capacitance&gt; -recomb &lt;recombination current&gt; -fermi &lt;fermi constant&gt;\n\n# Set SET propagation mode\n%&gt; set_SET_glitch_propagation_mode &lt;0: Vanilla STA-mode | 1: Detailed TimeStamp-based STA-mode | 2: Bounded TimeStamp-based STA-mode&gt;\n</code></pre> <p>Each mode or parameter has its own prerequisites and can be reviews at the related section SET Analysis, SET Glitch Generation and SET Glitch Propagation respectively.</p>"},{"location":"top_level_flows.html#automated-set-profile-analysis","title":"Automated SET Profile Analysis","text":"<p>The user is able to run a more comprehensive SET analysis, either for  the whole circuit or by selecting some critical gates and an exclusive set of applied particle profiles.</p>"},{"location":"top_level_flows.html#exhaustive-circuit-set-analysis","title":"Exhaustive Circuit SET Analysis","text":"<p>Based on every defined particle profile, an exhaustive SET analysis can be performed using the TCL command:</p> <pre><code>%&gt; perform_exhaustive_SET_analysis\n</code></pre> <p>In the exhaustive SET analysis flow, for every defined particle profile, SET scenarios are created targeting the output pins of every circuit's gate. Then for each defined SET scenario, SET Generation and Propapagation are performed. The hierarchy of this analysis can be summarsed as follows:</p> <pre><code>for each profile in SET_Particle_Profiles(all):\n    for each output_gatepin in Gatepins(all):\n        create_SET_scenario(profile, output_gatepin)\n\ngenerate_all_SET_scenarios_glitch\npropagate_all_SET_scenarios_glitch\n</code></pre>"},{"location":"top_level_flows.html#fast-circuit-set-analysis","title":"\"Fast\" Circuit SET Analysis","text":"<p>Alternatively, the user can select a specific set of output gatepins and a particle profiles using the TCL command:</p> <pre><code>%&gt; perform_SET_analysis -profiles {&lt;profile1&gt; &lt;profile2&gt; ...} -gatepins {&lt;gatepin1&gt; &lt;gatepin2&gt; ...}\n</code></pre> <p>Similarly to the exhaustive SET analysis, a complete SET analysis of glitch generation and propagation is performed, but only for the given particle profiles and gatepins. Thus, this approach provides more control for the user, because he can manipulate the scale of the SET analysis as he sees fit. The hierarchy of this SET analysis can be summarised with the following pseudocode:</p> <pre><code>for each profile in SET_Particle_Profiles(user):\n    for each gatepin in Gatepins(user):\n        create_SET_scenario(profile, gatepin)\n\ngenerate_all_SET_scenarios_glitch\npropagate_all_SET_scenarios_glitch\n</code></pre>"},{"location":"top_level_flows.html#custom-eco-set-scenario-analysis","title":"Custom (ECO) SET Scenario Analysis","text":"<p>Additionally, the user can examine particular generation and propagation scenario(s) using the following sequence of TCL commands:</p> <pre><code>%&gt; generate_SET_scenario_glitch (-scenario &lt;scenario_index&gt; | -all) ?-corner &lt;corner_index&gt;?\n\n%&gt; propagate_SET_scenario_glitch (-scenario &lt;scenario_index&gt; | -all) ?-corner &lt;corner_index&gt;?\n</code></pre> <p>For more details regarding the ECO capabilities, refer to Appendix A.</p>"},{"location":"top_level_flows.html#report-and-result-collection","title":"Report and Result Collection","text":"<p>The TCL commands that enable the user to verify and validate the SET analysis results are summarised below:</p> <ul> <li>SET Generation TCL Commands(s) for Report:<ul> <li><code>list_particle_profiles</code></li> <li><code>list_SET_scenarios</code></li> <li><code>list_SET_scenario_case_analysis</code></li> <li><code>report_SET_generation_probabilities</code></li> </ul> </li> <li>SET Propagation TCL Commands(s) for Report:<ul> <li><code>report_SET_scenario_timingpoints</code></li> </ul> </li> <li>Overview of SET Analysis TCL Commands(s) for Report:<ul> <li><code>list_static_probabilities</code></li> <li><code>list_saif_info</code></li> <li><code>list_all_gatepins_set_analysis_info</code></li> <li><code>list_gatepin_set_analysis_info</code></li> </ul> </li> </ul> <p>As mentioned in the section Error Reporting and Bugs, the output of the tool can be report using the <code>tee</code> Bash command while running UPSET:</p> <pre><code>%&gt; &lt;UPSET&gt; | tee &lt;log_file&gt;\n</code></pre> <p>Alternatively, the output of a specific TCL command(s) can be redirected by enclosing it as follows:</p> <pre><code>%&gt; log_output_to_file &lt;log_file&gt;\n%&gt; # ..... TCL commands .....\n%&gt; close_log_output_file\n</code></pre>"},{"location":"tutorial_flows.html","title":"Tutorial flows","text":"<p>This appendix presents some basic flows performing SET generation and propagation inside the ASP tool. For the following tutorials the design, whose schematic is presented in the following figure, is used.</p> <p> </p> Schematic of the design used for the following tutorials"},{"location":"tutorial_flows.html#eco-set-analysis","title":"ECO SET Analysis","text":"<p>In this tutorial, we present a flow to generate a SET glitch at the output of a gate and propagate it to the forward logic cone.</p>"},{"location":"tutorial_flows.html#set-generation-eco","title":"SET Generation (ECO)","text":"<p>Below, is shown a TCL script generating a SET glitch at the output gatepin of the U1 gate, as shown in the following figure.</p> <p> </p> Generating a SET at the output of the U1 gate Tutorial Script: SET Generation at U1 output gatepin<pre><code>load_lef ihp_013.lef\nload_lib ihp_013_typ.lib\nload_verilog tutorial_design.v\n\n# Set timing model to CCS\nset_timing_model ccs\n\n# Perform Static Timing Analysis (STA)\nreport_timing\n\n# Generate a SET glitch at the output gatepin of U1\ngenerate_SET_glitch -scenario U1/Q U3/B 0.5n 54p 391p 342f -corner 0\n</code></pre>"},{"location":"tutorial_flows.html#set-propagation-eco","title":"SET Propagation (ECO)","text":"<p>After the generation of the SET at the output of the gate, the generated SETs can be propagated to the forward logic cone, as shonw in the following figure.</p> <p> </p> Propagation of the SET defined at the input of U3 gate Tutorial Script: SET Propagation from U3 input gatepin B<pre><code>load_lef ihp_013.lef\nload_lib ihp_013_typ.lib\nload_verilog tutorial_design.v\n\n# Set timing model to CCS\nset_timing_model ccs\n\n# Create clock\ncreate_clock clk -period 1 -waveform {0 0.5}\nset_input_delay 0 -clock clk [all_inputs]\nset_output_delay 1 -clock clk [all_outputs]\n\n# Perform Static Timing Analysis (STA)\nreport_timing\n\n# Propagate a SET glitch from the input gatepin B of U3\npropagate_SET_glitch -gatepin U3/B -rise {0.538644 0.030392} -fall\n{1.557695 0.542653}\n</code></pre>"},{"location":"tutorial_flows.html#set-analysis-for-loaded-set-scenarios","title":"SET Analysis for Loaded SET Scenarios","text":"<p>In this tutorial, we present a flow of SET generation and propagation for the loaded SET Scenarios.</p>"},{"location":"tutorial_flows.html#set-generation-for-loaded-set-scenarios","title":"SET Generation for Loaded SET Scenarios","text":"<p>Below, we present a flow to generate SET glitches by creating first some SET scenarios. In contrast, to the Tutorial SET Generation (ECO) creating SET scenarios allows the user to generate multiple SETs at once, as shown in the following figure. It is important to note that each SET scenario is independent of the rest and the SET generation for one scenario does not affect the SET generation for another one.</p> <p> </p> Multiple SET Scenarios at the outputs of U1 and U2 gates <p>One way to create SET scenarios is by running the TCL command <code>create_SET_scenario</code> as shown in the the following script.</p> Tutorial Script: SET generation for the created SET scenarios<pre><code>load_lef ihp_013.lef\nload_lib ihp_013_typ.lib\nload_verilog tutorial_design.v\n\n# Set timing model to CCS\nset_timing_model ccs\n\n# Create SET scenarios\ncreate_SET_scenario U1/Q FF0/D 0.5n 61p 433p 355f\ncreate_SET_scenario U1/Q FF0/D 0.5n 48p 487p 381f\ncreate_SET_scenario U2/Q FF2/D 0.5n 52p 618p 347f\ncreate_SET_scenario U2/Q FF2/D 0.5n 46p 545p 285f\n\n# List created SET scenarios\nlist_SET_scenarios\n\n# Generate SETs for all created scenarios\ngenerate_SET_scenario_glitch -all\n</code></pre> <p>An alternative way to create SET scenarios is by creating a .scenario file where each line specifies a SET scenario. The scenario file for the SET scenarios created previously is presented below.</p> <pre><code>U1/Q FF0/D 0.5n 61p 433p 355f\nU1/Q FF0/D 0.5n 48p 487p 381f\nU2/Q FF2/D 0.5n 52p 618p 347f\nU2/Q FF2/D 0.5n 46p 545p 285f\n</code></pre> <p>Then, this file can be loaded into ASP by the TCL command load_SET_scenarios, as shown in the following TCL script.</p> Tutorial Script: SET generation for the loaded SET scenarios<pre><code>load_lef ihp_013.lef\nload_lib ihp_013_typ.lib\nload_verilog tutorial_design.v\n\n# Set timing model to CCS\nset_timing_model ccs\n\n# Load SET scenarios\nload_SET_scenarios tutorial_scenario_file.scenario\n\nList created SET scenarios\nlist_SET_scenarios\n\nGenerate SETs for all created scenarios\ngenerate_SET_scenario_glitch -all\n</code></pre>"},{"location":"tutorial_flows.html#set-propagation-for-loaded-set-scenarios","title":"SET Propagation for Loaded SET Scenarios","text":"<p>Similarly to SET generation for the created SET scenarios, the generated SET pulses of each SET scenario can be propagated to the forward logic cone, by running the TCL command propagate_SET_scenario_glitch.</p> SET propagation for the specified SET scenarios (a) SET Propagation for scenario 1 (b) SET Propagation for scenario 2 (c) SET Propagation for scenario 3 (d) SET Propagation for scenario 4 <p>The following TCL script propagates the SETs generated for each SET scenario specified in the scenario file loaded in the previous step.</p> Tutorial Script: Propagation of the generated SET pulse for the loaded SET scenarios<pre><code>load_lef ihp_013.lef\nload_lib ihp_013_typ.lib\nload_verilog tutorial_design.v\n\n# Set timing model to CCS\nset_timing_model ccs\n\n# Create clock\ncreate_clock clk -period 1 -waveform {0 0.5}\nset_input_delay 0 -clock clk [all_inputs]\nset_output_delay 1 -clock clk [all_outputs]\n\n# Load SET scenarios\nload_SET_scenarios tutorial_scenario_file.scenario\n\n# Perform Static Timing Analysis (STA)\nreport_timing\n\n# Generate SETs for all created scenarios\ngenerate_SET_scenario_glitch -all\n\n# Propagate the generated SETs for all created scenarios\npropagate_SET_scenario_glitch -all\n</code></pre>"},{"location":"tutorial_flows.html#vector-based-set-propagation-setting-case-analysis","title":"Vector-based SET Propagation setting Case Analysis","text":"<p>In Vector-based SET Analysis, the user must set values to the gates\u2019 side inputs to support logical masking. This is supported only in the case of SET scenarios stored in memory.</p> <p>Setting side input values is performed by creating a case analysis for a specified SET scenario. This is done by running the TCL command <code>create_SET_scenario_case_analysis</code>. The following script annotates values to side inputs of gates for the 1st SET scenario.</p> Tutorial Script: Propagation of the generated SET pulse for scenario 1 setting case analysis first<pre><code>load_lef ihp_013.lef\nload_lib ihp_013_typ.lib\nload_verilog tutorial_design.v\n\n# Set timing model to CCS\nset_timing_model ccs\n\n# Create clock\ncreate_clock clk -period 1 -waveform {0 0.5}\nset_input_delay 0 -clock clk [all_inputs]\nset_output_delay 1 -clock clk [all_outputs]\n\n# Create SET scenarios\nload_SET_scenarios tutorial_scenario_file.scenario\n\n# List created SET scenarios\nlist_SET_scenarios\n\n# Create SET case analysis for scenario 1\ncreate_SET_scenario_case_analysis -scenario 1 1 {U3/AN U6/A U10/B U11/B\nU12/A}\ncreate_SET_scenario_case_analysis -scenario 1 0 {U7/B U8/AN}\n\n# Perform Static Timing Analysis (STA)\nreport_timing\n\n# Generate SETs for all created scenarios\ngenerate_SET_scenario_glitch -scenario 1\n\n# Propagate the generated SETs for all created scenarios\npropagate_SET_scenario_glitch -scenario 1\n</code></pre> <p> </p> SET Propagation for scenario 1 with case analysis <p>The above figure shows the SET propagation for the above TCL script. Setting the side input of U6 to 1 results in the SET propagation stopping due to logical masking, since the input value 1 is the controlling value for the OR gate. Similarly, setting the input of U8 to 0 results in the SET propagation stopping due to logical masking.</p>"},{"location":"tutorial_flows.html#probabilistic-set-propagation","title":"Probabilistic SET Propagation","text":"<p>In the case of Probabilistic SET Analysis, the user must perform static probabilities annotation to support logical masking. The static probabilities annotation is performed by the TCL command <code>list_static_probabilities</code>. The following TCL script performs a probabilistic SET analysis, by annotating first the static probabilities by setting a 0.5 probability to all starting points, i.e. Primary Inputs (PIs) and FFs outputs, and computing them for the rest gatepins of the circuit using the 0-Algorithm. Then, SET generation and propagation are performed, setting the SET propagation mode to \"Vanilla\" STA-mode.</p> Tutorial Script: Probabilistic SET Propagation of the generated SET pulses for all scenarios<pre><code>load_lef ihp_013.lef\nload_lib ihp_013_typ.lib\nload_verilog tutorial_design.v\n# Set timing model to CCS\nset_timing_model ccs\n\n# Create clock\ncreate_clock clk -period 1 -waveform {0 0.5}\nset_input_delay 0 -clock clk [all_inputs]\nset_output_delay 1 -clock clk [all_outputs]\n\n# Create SET scenarios\nload_SET_scenarios tutorial_scenario_file.scenario\n\n# List created SET scenarios\nlist_SET_scenarios\n\n# Perform Static Timing Analysis (STA)\nreport_timing\n\n# Generate SETs for all created scenarios\ngenerate_SET_scenario_glitch -all\n\n# Set inputs static probabilities\nset_static_probability -value -0.5 -startpoints\n\n# List static probabilities\nlist_static_probabilities -significant_digits 5\n\n# Set the SET analysis mode to Probabilistic\nset_SET_analysis_mode 1\n\n# Set the SET glitch propagation mode to \"Vanila\" STA mode\nset_SET_glitch_propagation_mode 0\n\n# Propagate the generated SETs for all created scenarios\npropagate_SET_scenario_glitch -all\n</code></pre>"}]}